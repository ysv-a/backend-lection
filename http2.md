# Структура HTTP-запроса и ответа

Request:

```
POST /login HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7,und;q=0.6,lv;q=0.5
Cache-Control: no-cache
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Host: example.com
Pragma: no-cache
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36

email=asdad%40gm.com&password=as2354234
```

Response:
HTTP/1.1 200 OK
Server: Werkzeug/3.0.1 Python/3.12.0
Date: Thu, 15 Feb 2024 15:50:00 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 1876
Connection: close

{ТЕЛО ОТВЕТА - если сть}

## Методы

GET - получение ресурса, read

POST - создание ресурса, add

PUT - обновление, замена ресурса, place,replace

PATCH - частичная замена ресурса, edit

DELETE - удаление ресурса, delete

HEAD - получить заголовки

OPTIONS - получить список доступных методов

CONNECT and TRACE - исп. чтоб получить информацию о соединении к нашему серверу, вернет инф. о соеденении и трасировку запроса


## Структура запроса

### CRUD

GET https://example.com/books

GET https://example.com/books/1

POST https://example.com/books

PUT https://example.com/books/1

PATCH https://example.com/books/1

DELETE https://example.com/books/1




### Пример с GET - POST

GET https://example.com/books

GET https://example.com/books/1

POST https://example.com/books/create

POST https://example.com/books/1/update

POST https://example.com/books/1/patch

POST https://example.com/books/1/delete


### Параметры (query) в GET

GET https://example.com/books?sort=name&filter[name]=Alex

URI - Uniform Resource Identifier - унифицированный идентификатор ресурса - (эндпоинты)


## Безопасные методы и не безопасные

- GET
- HEAD
- OPTIONS

## Идемпотентность методов

### Идемпотентные:

- GET
- HEAD
- PUT
- DELETE
- OPTIONS

Если на сервер после повторных запросов ничего не меняется, то этот метод является - идемпотентным


PATCH https://example.com/books/1/like

```
Book:
-price = 100
-name = Test Book
-description = Descr Boook
-title = Meta Book
-like = 0
```


## Коды ответов:

https://www.webfx.com/web-development/glossary/http-status-codes/

Коды состояния HTTP 1xx — информационные ответы. Они указывают на то, что ваш веб-браузер сделал запрос на сервер и ожидает ответа.

Коды состояния HTTP 2xx — успешные ответы. Эти коды состояния сообщают клиенту, то есть веб-браузеру, что всё обрабатывается должным образом.

Коды состояния HTTP 3xx — перенаправления. Запрос получен, но для его выполнения нужен дополнительный шаг.

Коды состояния HTTP 4xx — ошибки на стороне клиента. Клиент сделал запрос, но целевая страница неверна.

Коды состояния HTTP 5xx — ошибки на стороне сервера. Запрос клиента был правильным, но сервер не смог его доставить.

### 2xx

200 — ОК - Запрос клиента выполнен успешно.

201 — Создан - Created - Запрос клиента выполнен успешно, и был создан новый ресурс. Это обычный ответ для метода POST и иногда для метода PUT.

204 — Нет содержимого - No Content - Действие выполнено успешно, но содержимое не возвращено. Полезно для действий, для которых не требуется тело ответа, например для DELETE. То есть если вы использовали DELETE, то тело ответа не нужно, значит, всё верно.

### 3xx

301 — Переехал навсегда - Moved Permanently - Ресурс перемещён в другое место, и местоположение известно.

302 — Переехал временно - Found - Запрашиваемый документ был найден и расположен временно по другому адресу.

304 — Не изменён - Not Modified - Запрошенный ресурс не был изменён. Чаще всего используется для кеширования

WWW -> no WWW

### 4xx

400 — Неверный запрос - Bad Request - В отправленном запросе есть проблемы, например, могут отсутствовать некоторые обязательные параметры. Часто к ответу 400 добавлено сообщение об ошибке, которое вы можете использовать для исправления запроса.

401 — Несанкционированный - Unauthorized - Особенно полезно для аутентификации, когда запрошенный ресурс недоступен для пользователя, владеющего запросом.

403 — Запрещено - Forbidden - Клиенту отказано в доступе к запрошенному ресурсу из-за отсутствия у клиента необходимых разрешений.

404 — Не найдено - Not Found - Предоставленный URL-адрес не идентифицирует какой-либо ресурс.

405 — Метод запрещён - Method Not Allowed - Используемый метод HTTP не разрешён для конкретного ресурса.

410 - Ушел - Gone - Целевой ресурс больше недоступен на исходном сервере, и это состояние, вероятно, будет постоянным.

422 — Необрабатываемый объект - Unprocessable Entity  - сервер понимает тип содержимого объекта запроса, и синтаксис объекта запроса правильный, но ему не удалось обработать содержащиеся в нем инструкции.


### 5xx

500 — Внутренняя ошибка сервера - Общий код ошибки, когда возникает непредвиденное условие и происходит сбой сервера.

502, 504 - Bad Gateway, Gateway Timeout - Сервер, действуя как шлюз или прокси, получил недопустимый ответ от входящего сервера, к которому он обращался при попытке выполнить запрос.

503 — Сервис недоступен - Запрос не выполнен из-за проблем с сервером. Чаще всего такое происходит, когда сервер перезагружается или находится на обслуживании. Также код появляется, когда серверу не хватает ресурсов или памяти.


# Версия протокола - Сайты и доменные имена

https://i.gyazo.com/465e5154d825bbaf8f88c60d8e2854f8.png

https://i.gyazo.com/fd87416fb0aeb40b711479c6fdae1ae5.png

HTTPS2: Pseudo-Header Fields

:authority: example.com

# Итого:

в запросе и ответе нужно указывать:

- версию HTTP
- метод запроса
- адрес ресурса к которму обращаемся

любой запрос к серверу и ответ от сервера по протоколу HTTP, состоит из мета данных, которые указываются в начале, после метаданных
(2ойного перевода строки), возвращается контент или передается контент

контент - тело запроса или ответа (body), а мета информация которая приведена в начале запроса-отвеа - HTTP заголовки

Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару имя-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой. (CRLF)

У метода GET - нет тела запроса!

```
POST /book HTTP/1.1
Accept: application/json
Accept-Encoding: gzip, deflate
Accept-Language: ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7,und;q=0.6,lv;q=0.5
Connection: keep-alive
Content-Length: 1702
Content-Type: application/json
Host: example.com
Origin: http://example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36

{
 "name": "Имя",
 "phone": "Телефон",
 "birthday": "Дата рождения",
 "email": "Email",
 "username": "username"
}
```

Response

```
HTTP/1.1 200
Server: nginx/1.18.0
Date: Thu, 15 Feb 2024 16:13:36 GMT
Content-Type: application/json
Content-Length: 7217
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0

{
 "name": "Имя",
 "phone": "Телефон",
 "birthday": "Дата рождения",
 "email": "Email",
 "username": "username"
}
```


# Заголовки для описания контента

## Content Type:

Заголовок-сущность Content-Type используется для того, чтобы определить MIME тип ресурса.

В ответах сервера заголовок Content-Type сообщает клиенту, какой будет тип передаваемого контента. В некоторых случаях браузеры пытаются сами определить MIME тип передаваемого контента, но их реакция может быть неадекватной.

- text/plain
- application/xml
- text/html
- text/csv
- text/javascript
- text/css
- application/pdf
- image/jpeg, image/png

![alt](https://i.gyazo.com/77508c2e60e14b5f24d3713ca17cef70.png)

application/octet-stream - Этот тип является базовым для бинарных данных. В связи с тем, что он подразумевает неопределённые бинарные данные

## Accept, Content-Length

HTTP заголовок запроса Accept указывает, какие типы контента, выраженные как MIME типы, клиент может понять.

Charset - Заголовок Accept-Charset запроса HTTP сообщает какую кодировку клиент может понять.

Content-Length - Заголовок Content-Length указывает размер отправленного получателю тела объекта в байтах.

Accept-Language - Запрос Accept-Language сообщает серверу, какие языки клиент понимает и какая локаль предпочтительнее

```
Request:
GET /books
Host: example.com
Accept: application/json

Response
HTTP/1.1 200 OK
Content Type: application/json
Content-Length: 120

[
	{
		"name": "HELLO!"
	}
]

```

```

Request:
POST /books
Host: example.com
Content-Lenght: 150
Accept: application/json
Content Type: application/json

{
	"name": "Book 1",
	"price": "500"
}

Response:
HTTP/1.1 201 CREATED
Content Type: application/json
Content-Lenght: 150

{
	"name": "Book 1",
	"price": "500"
}

```


```

Request:
POST /books
Host: example.com
Content-Lenght: 200
Accept: application/json
Content Type: application/xml

<?xml version="1.0" encoding="UTF-8"?>
<book>
	<name>Book 1</name>
	<price>500</price>
</book>

Response:
HTTP/1.1 200 OK
Content Type: application/json
Content-Lenght: 150

{
	"name": "Book 1",
	"price": "500"
}

```

## Urlencoded

Content-Type: application/x-www-form-urlencoded

```

Request:
POST /books
Host: example.com
Content-Lenght: 200
Accept: application/json
Content-Type: application/x-www-form-urlencoded

name=Book+1&price=500

```

## Проблема с файлами

```

Request:
POST /books
Host: example.com
Content-Lenght: 150
Accept: application/json
Content Type: application/json

{
	"name": "Book 1",
	"price": "500",
	"file": "BASE64"
}

Response:
HTTP/1.1 201 CREATED
Content Type: application/json
Content-Lenght: 150

{
	"name": "Book 1",
	"price": "500",
	"image": "/images/books_1_preview.png"
}

```


```

-----
Reqeust:
POST /books
Host: example.com
Content-Lenght: 150000
Content-Type: multipart/form-data; boundary="XSfdaas123sd"
Accept: application/json

--XSfdaas123sd
Content-Disposition: form-data;name="name"

Book 1

--XSfdaas123sd
Content-Disposition: form-data;name="photo"; filename="photo.jpg"
Content-Type: image/jpeg

ЯШФЫАВ№;ЕХЪ№;%№;%№%;

--XSfdaas123sd


Response:
HTTP/1.1 201 CREATED
Content Type: application/json
Content-Lenght: 150

{
	"name": "Book 1",
	"price": "500",
	"image": "/images/books_1_preview.png"
}


```


REST (Representational State Transfer) - это архитектурный стиль для построения распределенных систем, основанный на принципе использования стандартных протоколов, таких как HTTP, для взаимодействия между различными компонентами системы.

REST API (Application Programming Interface) - это набор правил и договоренностей, которые позволяют различным программам и приложениям обмениваться данными и взаимодействовать друг с другом с использованием принципов REST. Это позволяет разработчикам создавать приложения, которые могут общаться с веб-серверами и другими веб-сервисами с помощью стандартных HTTP-запросов.

- Клиент серверная архитектура (HTTP)

- Stateless

Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для обработки запроса, сервер не должен хранить информацию о состоянии клиента

- Кэширование

REST API должен поддерживать возможность кэширования ответов для улучшения производительности


- Единообразие интерфейса

Все ресурсы должны быть доступны через единый и унифицированный интерфейс, например через стандартные HTTP методы (GET, POST, PUT, DELETE)

- Layered system



Stateless - не использование глобального состояния, глобального стейта на сервере.
Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

Stateful - в этом случае сервер хранит информацию о предыдущих обращениях клиента, хранит информацию о сессии, какую-то часть контекста взаимодействия с клиентом. А затем может использовать эту информацию при обработке следующих запросов.


# Состояние: Cookies и сессии

Cookies (куки) — это механизм протокола HTTP, используемый для хранения данных браузером. Они позволяют отслеживать или идентифицировать возвращающихся посетителей. По сути, единственный надёжный способ понять что перед нами тот же самый пользователь.

Именно благодаря кукам, гугл узнает вас и преследует рекламой того, что вы недавно искали, на сайтах, которые вроде бы не должны знать о ваших предпочтениях.

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.

Куки часто используются для:

- Управления сеансом (логины, корзины для виртуальных покупок)
- Персонализации (пользовательские предпочтения)
- Трекинга (отслеживания поведения пользователей)

# Параметры:

path - URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.

domain - Домен определяет, где доступен файл куки. (*.site.com)

expires, max-age - По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными («session cookies»).

secure - Куки следует передавать только по HTTPS-протоколу.

httpOnly - Эта настройка запрещает любой доступ к куки из JavaScript.

samesite используется браузерами для определения того, как следует обрабатывать основные и сторонние файлы cookie. Браузеры могут разрешать или блокировать такие файлы cookie в зависимости от атрибута и сценария.

samesite=strict - Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта.

samesite=lax - Режим Lax так же, как и strict, запрещает браузеру отправлять куки, когда запрос происходит не с сайта, но добавляет одно исключение.


# Сессии

Сессия, это абстракция, созданная для удобной работы с индивидуальными пользователями. Она используется для идентификации пользователей и позволяет отличать их друг от друга. Например, аутентификация на сайтах построена поверх механизма сессии.

Сессии реализуются на уровне конкретных фреймворков и только в PHP сессии встроены в язык. Общий принцип работы сессии сводится к трём операциям:

- Старт сессии. Так мы говорим системе, что хотим начать следить за пользователем. Во многих фреймворках эта операция выполняется неявно, при попытке чтения или записи в сессию.
- Запись данных в сессию.
- Чтение данных из сессии.

Старт сессии на техническом уровне означает установку специальной куки в браузер. Обычно эта кука содержит идентификатор сессии, который уникален для каждого пользователя. Данные сессии могут храниться где угодно, это зависит от конкретной реализации. В этом одно из ключевых отличий работы с пользователями напрямую через куки или через сессию. Сессия более высокоуровневая абстракция.

Работая с сессией не надо думать про имена кук, про сериализацию и десериализацию составных данных. Всё это происходит автоматически.

Сама сессия представляет собой структуру данных на сервере (может храниться в виде файла, в базе данных, в памяти или другими способами).


# Сохранение данных в браузере

Горизонтальное масштабирование - больше серверов

![alt](https://i.gyazo.com/55ae1ebb0e8db062a1329fc1d9dbfd81.png)

![alt](https://i.gyazo.com/02b92bbe860f429e6b065ce8b4e81832.png)

![alt](https://i.gyazo.com/36f19cd4e2cd0fd6215b7450d6ba287c.png)

![alt](https://i.gyazo.com/0fb36aa344ffd8ec22d20ce5438f5086.png)


# Сессии

![alt](https://i.gyazo.com/133a9a35bc6e9fdaab574ba4ae5f6eb4.png)

![alt](https://i.gyazo.com/86a1d2a5fd103cb285c8a63d7c36c5f0.png)

![alt](https://i.gyazo.com/b9f4e5390c49fc493b45854c92b8f076.png)
