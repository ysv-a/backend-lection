# Аутентификации

Аутентификация — процедура проверки подлинности, например: проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользовательских логинов; подтверждение подлинности электронного письма путём проверки цифровой подписи письма по открытому ключу отправителя;

Аутентификация — это процесс верификации идентичности пользователя, системы или приложения.

![alt](https://i.gyazo.com/2781b308e7e61d8b742ce83d54eae416.png)

![alt](https://i.gyazo.com/9eee1bf62b2e8505ea46f86fa0917de4.png)

https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#authentication_schemes

## Basic Auth

![alt](https://i.gyazo.com/c10103cfdd47f26e14d8ea1b0bdc53f4.png)


## Cookie Auth

Cookies (куки) — это механизм протокола HTTP, используемый для хранения данных браузером.

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.

![alt](https://i.gyazo.com/d9f4832f9f664ee1db17965f06df271e.png)

![alt](https://i.gyazo.com/55ae1ebb0e8db062a1329fc1d9dbfd81.png)

![alt](https://i.gyazo.com/02b92bbe860f429e6b065ce8b4e81832.png)

![alt](https://i.gyazo.com/36f19cd4e2cd0fd6215b7450d6ba287c.png)

![alt](https://i.gyazo.com/0fb36aa344ffd8ec22d20ce5438f5086.png)

## Session Auth

Сессия, это абстракция, созданная для удобной работы с индивидуальными пользователями. Она используется для идентификации пользователей и позволяет отличать их друг от друга. Например, аутентификация на сайтах построена поверх механизма сессии.

Сессии реализуются на уровне конкретных фреймворков и только в PHP сессии встроены в язык. Общий принцип работы сессии сводится к трём операциям:

- Старт сессии. Так мы говорим системе, что хотим начать следить за пользователем. Во многих фреймворках эта операция выполняется неявно, при попытке чтения или записи в сессию.
- Запись данных в сессию.
- Чтение данных из сессии.

Старт сессии на техническом уровне означает установку специальной куки в браузер. Обычно эта кука содержит идентификатор сессии, который уникален для каждого пользователя. Данные сессии могут храниться где угодно, это зависит от конкретной реализации. В этом одно из ключевых отличий работы с пользователями напрямую через куки или через сессию. Сессия более высокоуровневая абстракция.

Работая с сессией не надо думать про имена кук, про сериализацию и десериализацию составных данных. Всё это происходит автоматически.

Сама сессия представляет собой структуру данных на сервере (может храниться в виде файла, в базе данных, в памяти или другими способами).

![alt](https://i.gyazo.com/c10df3238beec8ea90f56115cb4fec60.png)

![alt](https://i.gyazo.com/133a9a35bc6e9fdaab574ba4ae5f6eb4.png)

![alt](https://i.gyazo.com/86a1d2a5fd103cb285c8a63d7c36c5f0.png)

![alt](https://i.gyazo.com/b9f4e5390c49fc493b45854c92b8f076.png)


## Bearer Auth

(предъявитель)

![alt](https://i.gyazo.com/068485d9db7c8f8db6ca1282979abc68.png)

![alt](https://i.gyazo.com/31d803f57e86fa0c90c40544f09e2eba.png)


# JWT

https://jwt.io/

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0
```

JWT (JSON Web Token) - это открытый стандарт (RFC 7519), который определяет компактный и безопасный способ передачи информации между двумя участниками в виде закодированного JSON объекта.

JWT зашифрован и подписан с помощью ключа, чтобы предотвратить несанкционированный доступ или изменение данных.

Токены создаются сервером, подписываются секретным ключом и передаются клиенту.

Одним из принципов REST является независимость от состояния (stateless). Это значит, что клиент должен сам позаботиться о своей аутентификации при каждом запросе.

JWT состоит из трех основных частей: заголовка (header), нагрузки (payload) и подписи (signature). Заголовок и нагрузка формируются отдельно, а затем на их основе вычисляется подпись.

## Структура

**Header**

Обычно заголовок состоит из двух полей: типа токена (в данном случае JWT) и алгоритма хэширования подписи:


```
{
  "typ": "JWT",
  "alg": "HS256"
}
```

## Payload

Payload — это любые данные, которые вы хотите передать в токене. Но стандарт предусматривает несколько зарезервированных полей:

- iss — (issuer) издатель токена
- sub — (subject) "тема", назначение токена
- aud — (audience) аудитория, получатели токена
- exp — (expire time) срок действия токена
- nbf — (not before) срок, до которого токен не действителен
- iat — (issued at) время создания токена
- jti — (JWT id) идентификатор токена

Все эти поля не являются обязательными, но их использование не по назначению может привести к коллизиям.

Любые другие данные можно передавать по договоренности между сторонами, использующими токен.

Payload не шифруется при использовании токена, поэтому не стоит передавать в нем данные, которые не должны попасть в открытый доступ.

## Signature

Подпись вычисляется на основе заголовка и нагрузки. Таким образом, если кто-то попытается изменить данные в токене, он не сможет изменить подпись, не зная приватного ключа. При аутентификации приватным ключом может выступать пароль пользователя (или хеш от пароля).

## Логика

После первого логина, клиенту возвращается сгенерированный сервером JWT. При каждом следующем запросе, клиент должен передавать JWT установленным API способом (например, через заголовок или как параметр запроса). Сервер декодирует header и payload и проверяет зарезервированные поля. Если все в порядке, по указанному в header алгоритму составляется подпись. Если полученная подпись совпадает с переданной, пользователя авторизуют.


## Refresh tokens

В современных схемах аутентификации, основанных на JWT, после прохождения аутентификации пользователь получает два токена:

- access token — JWT, на основе которого приложение идентифицирует и авторизует пользователя;
- refresh token — токен произвольного формата, служащий для обновления access token.

Access token при таком подходе имеет сильно ограниченное время жизни (например, одну минуту). Refresh token же имеет длительное время жизни (день, неделя, месяц), но он одноразовый и служит исключительно для обновления access token пользователя.

Схема аутентификации в таком случае выглядит следующим образом:

- пользователь проходит процедуру аутентификации и получает от сервера access token и refresh token;
- при обращении к ресурсу пользователь передает в запросе свой access token, на основе которого сервер идентифицирует и авторизует клиента;
- при истечении access token клиент передает в запросе свой refresh token и получает от сервера новые access token и refresh token;
- при истечении refresh token пользователь заново проходит процедуру аутентификации.

# Подходы:

![alt](https://i.gyazo.com/9589fd9d75969080a78dc860615616bd.png)

![alt](https://i.gyazo.com/62bed6a55de83cfec1fc72d336bbbe22.png)

## Statefull

- На клиенте только индентификатор
- Содержимое на сервере
- Легко отозвать
- Централизованное хранилище
- Хорошее observability (наблюдаемость) (логи, видим содержимое сессий)

## Stateless

- На клиенте все данные из сессий
- Просто так не отозвать
- Хорошо масштабируется
- Сложно расследовать инциденты постфактум


# Проблема аутентификации через JWT (JWT и сессии) JWT as a session mechanism

![alt](https://i.gyazo.com/a498e9c88d6c6d604f45433757fa68e8.png)


Вместо того, чтобы хранить JWT в локальном хранилище, сохраните его в файле cookie (не рекомендуется)

Использовать аутентификацию на стороне сервера с использованием сеансов и файлов cookie (рекомендуется).

В файле cookie: появляется уязвимость для CSRF-атак

В другом месте, например в локальном хранилище: теперь нет уязвимости для CSRF-атак, но ваше приложение или сайт теперь требуют JavaScript для работы, и вы только что сделали себя уязвимыми для совершенно другого, потенциально худшего класса уязвимостей.

Единственная правильная защита от CSRF — это токен CSRF. Механизм сеанса здесь не имеет значения.


# OAuth 2.0

OAuth 2.0 — протокол авторизации, позволяющий выдать одному сервису (приложению) права на доступ к ресурсам пользователя на другом сервисе.

Ключевые компоненты OAuth 2.0:

Владелец ресурса: обычно пользователь, предоставляющий разрешение на доступ к своей информации.

Клиент: приложение, запрашивающее доступ к учетной записи пользователя.

Сервер авторизации: Сервер, который аутентифицирует владельца ресурса и выдает токены доступа Клиенту.

Сервер ресурсов: сервер, на котором размещены защищенные ресурсы, способный принимать запросы защищенных ресурсов и отвечать на них с использованием токенов доступа.

```py
from flask import Flask, redirect, request, url_for
import requests

app = Flask(__name__)

CLIENT_ID = 'YOUR_CLIENT_ID'
CLIENT_SECRET = 'YOUR_CLIENT_SECRET'
REDIRECT_URI = 'http://localhost:5000/login/callback'

@app.route('/')
def home():
    return 'Welcome! <a href="/login">Login with Facebook</a>'

@app.route('/login')
def login():
    fb_oauth_url = f'https://www.facebook.com/v14.0/dialog/oauth?client_id={CLIENT_ID}&redirect_uri={REDIRECT_URI}'
    return redirect(fb_oauth_url)

@app.route('/login/callback')
def login_callback():
    code = request.args.get('code')
    if code:
        token_url = 'https://graph.facebook.com/v14.0/oauth/access_token'
        params = {
            'client_id': CLIENT_ID,
            'redirect_uri': REDIRECT_URI,
            'client_secret': CLIENT_SECRET,
            'code': code
        }
        response = requests.get(token_url, params=params)
        access_token = response.json().get('access_token')
        return f'Access Token: {access_token}'
    else:
        return 'Authorization failed.'

```

# OpenID Connect

OpenID Connect — это совместимый протокол аутентификации, основанный на спецификации OAuth 2.0 (IETF RFC 6749 и 6750).

OIDC — это безопасный механизм, позволяющий приложению связаться со службой идентификации, чтобы получить необходимые данные о пользователе и вернуть их обратно в приложение, обеспечив полную защиту данных.

https://www.advantshop.net/help/pages/openid-yandex

# SSO

Единый вход (SSO - single sign-on) — это процесс аутентификации пользователя, который позволяет пользователю получить доступ к нескольким приложениям или системам с помощью всего одного набора учетных данных.

# Keycloak

Keycloak - это универсальный открытый инструмент для управления аутентификацией и управления доступом (IAM)

Приложение для реализации единой точки аутентификации и авторизации.

# LDAP

LDAP, или Lightweight Directory Access Protocol, — это протокол быстрого доступа к каталогам.

Каталог — это особый вид базы данных, подобие адресной книги, где содержатся краткие описательные сведения о каких-либо сущностях.

https://blog.skillfactory.ru/glossary/ldap/


# Авторизация

Это процесс предоставления пользователю доступа к определенным ресурсам или функциям системы после успешной аутентификации. Авторизация определяет, какие действия может выполнять пользователь в пределах системы на основе его роли или прав доступа.

## Django

https://docs.djangoproject.com/en/5.0/topics/auth/default/


## Laravel

https://laravel.su/docs/10.x/authorization
