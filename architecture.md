# Архитектура

UI - контролееры, с чем взаимодействует пользователь

Application - UseCase\Service - прикладной слой - операции прикладного уровня которые относятся к приложениюю

В Application мы не можем работать с сессиями, куками и прочими моментами, т.к в др UI например ConsoleController там этого нет.

Domain - Model\Repository\DTO\VO and etc

![alt](https://i.gyazo.com/e7a4ad79c6b68c50c22e48a22567b436.png)

## Application

Одно из главных преимуществ создания сервисных классов — это консолидация всей работы с бизнес-логикой и инфраструктурой, включая хранилища данных, такие как базы данных и файлы, в одном месте, оставляя Web, API, Console и другим интерфейсам работу исключительно со своими обязанностями.

Часть для работы с Web должна просто готовить данные для сервис-классов и показывать результаты пользователю. То же самое про другие интерфейсы.

Все сервис-классы, которые прячут логику приложения внутри себя и предоставляют удобные методы для Web, API и других частей приложения, формируют структуру, которая имеет множество имён:

- сервисный слой (Service layer), из-за сервисных классов.
- слой приложения (Application layer), потому что он содержит всю логику приложения, исключая интерфейсы к нему.
- в GRASP этот слой называется Слой контроллеров (Controllers layer)

Контроллеры очень просты. Они лишь передают данные из объектов-запросов в сервисные классы.

Простая валидация ввода производится в формах.

В сервисах и в сущностях производится проверка бизнес-требований.


## DTO

Data Transfer Object — один из шаблонов проектирования, используется для передачи данных между подсистемами приложения.

DTO — это так называемый value-object на стороне сервера, который хранит данные, используемые в слое представления.

Суть DTO не только в заполнении, но и в том, что DTO должно передавать валидные данные между слоями.

## VO

Value Object - Маленький объект для хранения величин таких как деньги или диапазон дат, равенство которых не основано на идентичности.

Value Object — это иммутабельный тип, значение которого задается при создании и не меняется на протяжении всей жизни объекта. Не имеет идентификатора. Если два VO структурно одинаковы — они эквивалентны.

## Обработка ошибок

https://laravel.su/docs/8.x/errors

```
            Throwable(checked)
         /                    \
Error(unchecked)    Exception(checked)
                                   \
                      RuntimeException(unchecked)

```

Проверяемые исключения, которые обязаны быть пойманы или объявлены в сигнатуре, и непроверяемые, которые могут быть выброшены без всяких дополнительных условий.

Throwable, Exception и все их наследники - проверяемые исключения. Кроме Error, RuntimeException и всех их наследников. Их можно выбросить везде.

Error - означает ошибку языка PHP, например TypeError, ParseError, и т.д.

RuntimeException - означает ошибку времени выполнения, не зависящую от нашего кода, например проблемы с соединением с базой данных.

InvalidArgumentException - создаётся исключение, если аргумент не соответствует ожидаемому типу.

LogicException - Исключение, которое представляет ошибку в логике программы. Такой тип исключений должен непосредственно привести к исправлениям в вашем коде.

DomainException - создаётся исключение, если значение не соответствует определённой допустимой области данных.

Класс ModelNotFoundException в Laravel от наследован от \RuntimeException.

обычно нужно писать такие Exception

```
/**
 * @throws ModelNotFoundException
 * @throws BusinessException
 */
```

Если наследуемся от RuntimeException, то такие проверки можно опустить, т.к такие обработки ошибок настроены в глобальном обработчике ошибок Laravel



## Бизнес логика и логика приложения

Бизнес-Логика (деловые регламенты, доменные модели) - это моделирование объектов и процессов предметной области (т.е. реального мира). Это то, что программа должна делать (от слова “дело” - именно так переводится слово “business”), и ради чего она создается.

Бизнес-логика, на английском Domain logic или Логика предметной области, это та логика, которую представляют себе пользователи или заказчики.

Например, для игры это будет полный свод её правил, а для финансового приложения - все сущности, которые там есть и все правила расчетов.

Для блога всю бизнес-логику можно грубо описать так: есть статьи, у них есть заголовок и текст, администратор может их создать и опубликовать, а другие пользователи могут видеть все опубликованные статьи на главной странице. Логику приложения: SEO, интеграции с API, авторизации, поиск контента и т.д

Бизнес-логика относится к правилам и процедурам, которые управляют бизнесом, включая такие вещи, как ценообразование, скидки, уровни запасов, права клиентов и т. д. С другой стороны, логика приложения — это код, который реализует эти бизнес-правила в конкретном приложении.

Например, бизнес-логика связана с расчетом процентов по кредиту, тогда как логика приложения связана с тем, что происходит, когда пользователь нажимает кнопку «Получить предварительное одобрение» на веб-сайте.


Логика приложения - это то, что обеспечивает и координирует работу Бизнес-Логики. (скажем, уведомляет пользователей и сторонние приложения о протекании процесса вычисления доходов)

Логика приложения — это механизм, который устраняет разрыв между бизнес-логикой и пользовательским интерфейсом: он берет входные данные бизнес-логики и превращает их во внешние выходные данные, которые видит пользователь.

Другими словами, действия, выполняемые с логикой приложения, не имеют ничего общего с бизнесом, они просто обрисовывают в общих чертах ряд действий, запускаемых событием.


Анемичная модель - когда сущности только хранят данные, а работают с ними другие классы

Богатая модель - когда модель сама работает со своими данными

## Структура проекта

в проектах нет правильной структуры.

**плоская структура, где все вкладывается в корень**

```
Model
    Blog
    Category
    Article
    User
    Post

DTO
    PostDTO
    AuthorDTO

VO
    Email
    Money

```

**по домменам**

```
Http
	Controllers
Application
	UseCases
		Blog
			Post
			Category
Domain
	Blog
		Model
			Post
			Category
		Repository
		Service
		DTO
        VO
Infrastructure
```

**по модулям**

```
User
	Model
		User
	Repository
		UserRepository
	UseCase
		Auth
    DTO
        UserDTO

Blog
	Model
		Post
		Category
	Repository
		PostRepository
	Service
		Service
	DTO
		PostDTO
		CategoryDTO

```

**по уровням**

```
Model
	User
        User
	Shop
		Product
		Category
	Blog
		Post
		Category

UseCase
	User
        User
	Shop
		Product
		Category
	Blog
		Post
		Category

DTO
    Blog
        PostDTO
        CategoryDTO
```


# Книги:

https://habr.com/ru/post/653421/

Чистый код: создание, анализ и рефакторинг. Библиотека программиста | Мартин Роберт

Clean Architecture / Чистая архитектура  | Мартин Роберт

Идеальный программист. Как стать профессионалом разработки ПО | Мартин Роберт

Refactoring. Improving the Design of Existing Code / Рефакторинг. Улучшение проекта существующего кода | Martin Fowler

DDD:

Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем | Эванс Эрик
