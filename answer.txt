1 ======== ======== ======== 

HTTP:
- Версии протокола HTTP. Отличия
- Протокол HTTPS. Протокол TLS


HTTP/1.0 - открывыает соедиение, запрашивает данные, получает данные, после этого соединение разрывается
проблема: каждый раз происходит процесс рукопожатия
HTTP/1.1 (оптимизированный) - используется одно и тоже подключение для последовательной отправки нескольких запросов

HTTP2
Проблему потери времени при последовательной загрузки файлов, решили в версии http2
Вместо простого текста теперь можно передавать запросы и ответы в более оптимальном бинарном формате и дали возможность мультиплексировать запросы
Мультиплексирование — это одно TCP-соединение для нескольких запросов и ответов.

HTTPS
- HTTP-сообщения разбиваются на один или несколько фреймов с общим заголовком. Это сокращает дополнительное время приёма-передачи (RTT), ускоряя загрузку сайта без какой-либо оптимизации.
- Заголовки сжимаются при помощи алгоритма HPACK. Происходит сокращение информации для обмена между браузером и сервером.
- HTTP/2 мультиплексирован.
- Параллельный запрос статических элементов:

Протокол TLS (Transport Layer Security) - это криптографический протокол, который обеспечивает защищенную связь между клиентом и сервером в интернете. Он используется для шифрования данных и защиты их от несанкционированного доступа.


2 ======== ======== ======== 

Структура HTTP сообщений (заголовки, тело запроса и т.д):
- Методы и популярные коды HTTP
- Безопасные методы и не безопасные, идемпотентность
- Что такое Accept и Content Type. С помощью какого Content Type можно загружать файлы на сервер

POST /login HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/

email=asdad%40gm.com&password=as2354234

Коды состояния HTTP 1xx — информационные ответы. Они указывают на то, что ваш веб-браузер сделал запрос на сервер и ожидает ответа.

Коды состояния HTTP 2xx — успешные ответы. Эти коды состояния сообщают клиенту, то есть веб-браузеру, что всё обрабатывается должным образом.

Коды состояния HTTP 3xx — перенаправления. Запрос получен, но для его выполнения нужен дополнительный шаг.

Коды состояния HTTP 4xx — ошибки на стороне клиента. Клиент сделал запрос, но целевая страница неверна.

Коды состояния HTTP 5xx — ошибки на стороне сервера. Запрос клиента был правильным, но сервер не смог его доставить.

200 — ОК - Запрос клиента выполнен успешно.

201 — Создан - Created - Запрос клиента выполнен успешно, и был создан новый ресурс. Это обычный ответ для метода POST и иногда для метода PUT.

204 — Нет содержимого - No Content - Действие выполнено успешно, но содержимое не возвращено. Полезно для действий, для которых не требуется тело ответа, например для DELETE. То есть если вы использовали DELETE, то тело ответа не нужно, значит, всё верно.

### 3xx

301 — Переехал навсегда - Moved Permanently - Ресурс перемещён в другое место, и местоположение известно.

302 — Переехал временно - Found - Запрашиваемый документ был найден и расположен временно по другому адресу.

304 — Не изменён - Not Modified - Запрошенный ресурс не был изменён. Чаще всего используется для кеширования

### 4xx

400 — Неверный запрос - Bad Request - В отправленном запросе есть проблемы, например, могут отсутствовать некоторые обязательные параметры. Часто к ответу 400 добавлено сообщение об ошибке, которое вы можете использовать для исправления запроса.

401 — Несанкционированный - Unauthorized - Особенно полезно для аутентификации, когда запрошенный ресурс недоступен для пользователя, владеющего запросом.

403 — Запрещено - Forbidden - Клиенту отказано в доступе к запрошенному ресурсу из-за отсутствия у клиента необходимых разрешений.

404 — Не найдено - Not Found - Предоставленный URL-адрес не идентифицирует какой-либо ресурс.

405 — Метод запрещён - Method Not Allowed - Используемый метод HTTP не разрешён для конкретного ресурса.

410 - Ушел - Gone - Целевой ресурс больше недоступен на исходном сервере, и это состояние, вероятно, будет постоянным.

422 — Необрабатываемый объект - Unprocessable Entity  - сервер понимает тип содержимого объекта запроса, и синтаксис объекта запроса правильный, но ему не удалось обработать содержащиеся в нем инструкции.


### 5xx

500 — Внутренняя ошибка сервера - Общий код ошибки, когда возникает непредвиденное условие и происходит сбой сервера.

502, 504 - Bad Gateway, Gateway Timeout - Сервер, действуя как шлюз или прокси, получил недопустимый ответ от входящего сервера, к которому он обращался при попытке выполнить запрос.

503 — Сервис недоступен - Запрос не выполнен из-за проблем с сервером. Чаще всего такое происходит, когда сервер перезагружается или находится на обслуживании. Также код появляется, когда серверу не хватает ресурсов или памяти.

## Безопасные методы и не безопасные

- GET
- HEAD
- OPTIONS

## Идемпотентность методов

### Идемпотентные:

- GET
- HEAD
- PUT
- DELETE
- OPTIONS

Если на сервер после повторных запросов ничего не меняется, то этот метод является - идемпотентным


HTTP заголовок запроса Accept указывает, какие типы контента, выраженные как MIME типы, клиент может понять.
В ответах сервера заголовок Content-Type сообщает клиенту, какой будет тип передаваемого контента. В некоторых случаях браузеры пытаются сами определить MIME тип передаваемого контента, но их реакция может быть неадекватной.

Content-Type: multipart/form-data; 

3  ======== ======== ======== 

Рассказать про CSRF, перечислить способы защиты.

Межсайтовая подделка запроса – это разновидность вредоносного эксплойта, при котором неавторизованные команды выполняются от имени аутентифицированного пользователя.

SameSite — предназначен для обеспечения некоторой защиты от атак подделки межсайтовых запросов
– None, в этом случае ограничения на файлы Cookie не устанавливаются;
– Strict, устанавливается полный запрет на отправку любых Cookie;

CSRF Токен


4 ======== ======== ======== 

CORS. Preflighted Request.
Кроссдоменные запросы (CORS)
Использование Origin-заголовков для возможности из JavaScript осуществлять Ajax-запросы к API на другом домене.

Белый список методов и заголовков который браузер использует в своей политике работы с разными сайтами из js.
Именно эти методы браузер считает безопасными и с помощью которых сложно в принципе сломать другой сайт.
**Методы:**
- GET
- POST
- HEAD

**Заголовки:**
- Connection, User-agent, Content-Length ....
- Accept
- Accept-Language
- Content-Language
- Content-Type
 - application/x-www-form-urlencoded
 - multipart/form-data
 - text/plain

 Access-Control-Allow-Origin: *

 Как только браузер сомневается в чем то, он вместо оригинального запроса сначало отправляет OPTIONS запрос, которым проверяет можно ли с этим сервером работать.
Если вернулся валидный ответ, только в этом случаем отправляются "опасные запросы".

Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS (OPTIONS)
Access-Control-Expose-Headers: Content-Type


5  ======== ======== ======== 

Сессии и cookie:
- как работает аутентификация на основе сессии и cookie
- настройка безопасных cookie

Cookies (куки) — это механизм протокола HTTP, используемый для хранения данных браузером. Они позволяют отслеживать или идентифицировать возвращающихся посетителей. По сути, единственный надёжный способ понять что перед нами тот же самый пользователь.

path
domain - Домен определяет, где доступен файл куки. (*.site.com)
expires
secure
httpOnly
samesite

Сессия, это абстракция, созданная для удобной работы с индивидуальными пользователями. Она используется для идентификации пользователей и позволяет отличать их друг от друга. Например, аутентификация на сайтах построена поверх механизма сессии.


6  ======== ======== ======== 
.env и composer.json:
в composer.json, что такое require и require-dev
чем отличается composer install от composer update
рассказать про версионирование пакетов, что означают версии

.env
это централизованное хранилище настроек
composer.json - менеджер пакетов для PHP.
require какие пакеты нужно подключать всегда
require-dev - девелоперские пакеты, т.е подключать пакеты только в среде разработки

composer.lock - Файл composer.lock сохраняет текущий список установленных зависимостей и их версии

Команда composer install делает следующее:

Проверяет существует ли composer.lock:
— если нет, резолвит зависимости и создаёт его
— если composer.lock существует, устанавливает версии, указанные в нём

Команда composer update:

— Проверяет composer.json
— Определяет последние версии на основе указанных в этом файле
— Устанавливает последние версии
— Обновляет composer.lock в соответствии с установленными

3 - Patch - увеличивается при исправлении ошибок с обеспечением обратной совместимости
2 - minor - увеличивается при добавлении функциональных возможностей с обеспечением обратной совместимости
1 - major - увеличивается при внесении изменений, приводящих к несовместимости



7  ======== ======== ======== 
Архитектурные концепции фреймворка:

очкой входа для всех запросов к приложению Laravel является файл public/index.php
Файл index.php загружает автозагрузчик, созданный менеджером пакетов Composer, а затем извлекает экземпляр приложения Laravel из bootstrap/app.php
Первым действием, предпринимаемым самим Laravel, является создание экземпляра приложения / контейнера служб.

Затем входящий запрос отправляется либо HTTP-ядру, либо ядру консоли, в зависимости от типа запроса, поступающего в приложение. Эти два ядра служат центральным местом, через которое проходят все запросы.

Одним из наиболее важных действий начальной загрузки ядра является загрузка поставщиков служб вашего приложения. Все поставщики служб приложения настраиваются в массиве providers конфигурационного файла config/app.php.

Laravel будет перебирать этот список поставщиков и создавать экземпляры каждого из них. После создания экземпляров поставщиков, будет вызван метод register всех поставщиков. Затем, как только все поставщики будут зарегистрированы, будет вызван метод boot каждого из них. Это сделано для того, чтобы те поставщики служб, которые имеют зависимости от других поставщиков, могли быть вызваны гарантированно после создания своих зависимостей, вызываемых в методе boot.


Маршрутизация:
Маршрутизатор позволяет регистрировать маршруты, отвечающие на любой HTTP-метод:
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);


Контроллеры
Контроллеры могут сгруппировать связанную логику обработки запросов в один класс. Например, класс UserController может обрабатывать все входящие запросы, относящиеся к пользователям, включая отображение, создание, обновление и удаление пользователей. По умолчанию контроллеры хранятся в каталоге app/Http/Controllers.

Middleware
Посредник обеспечивает удобный механизм для проверки и фильтрации HTTP-запросов, поступающих в ваше приложение.


8 ======== ======== ========  

Архитектура фреймворка:
- рассказать про Контейнеры (DI)
- фасады и контракты, как это работает и что это такое
- что такое auto-wiring


Контейнер служб (service container, сервис-контейнер) Laravel – это мощный инструмент для управления зависимостями классов и выполнения внедрения зависимостей.
зависимости классов «вводятся» в класс через конструктор в виде аргументов или, в некоторых случаях, через методы-сеттеры. При создании класса или вызове методов фреймворк смотрит на список
аргументов и, если нужно, создаёт экземпляры необходимых классов и сам подаёт их на вход конструктора или метода.

Фасады предоставляют «статический» интерфейс для классов, доступных в контейнере служб приложения.
Фасады Laravel служат «статическими прокси» для базовых классов в контейнере служб, обеспечивая преимущества краткого, выразительного синтаксиса при сохранении большей тестируемости и гибкости, чем традиционные статические методы.

«Контракты» Laravel – это набор интерфейсов, которые определяют основные службы фреймворка.
Каждый контракт имеет соответствующую реализацию, предусмотренную структурой.

В отличие от фасадов, которые не требуют, чтобы они находились в конструкторе вашего класса, контракты позволяют вам определять явные зависимости для ваших классов. Некоторые разработчики предпочитают явно определять свои зависимости таким образом и поэтому предпочитают использовать контракты, в то время как другие разработчики пользуются удобством фасадов. В общем, большинство приложений могут без проблем использовать фасады во время разработки.

"auto-wiring" - автоматическое разрешение зависимостей
ReflectionClass: сообщает информацию о классе.

9  ======== ======== ======== 

Что такое сервисный слой приложения.
Что такое DTO, VO.

Одно из главных преимуществ создания сервисных классов — это консолидация всей работы с бизнес-логикой и инфраструктурой, включая хранилища данных, такие как базы данных и файлы, в одном месте, оставляя Web, API, Console и другим интерфейсам работу исключительно со своими обязанностями.

Data Transfer Object — один из шаблонов проектирования, используется для передачи данных между подсистемами приложения.
DTO — это так называемый value-object на стороне сервера, который хранит данные, используемые в слое представления.
Суть DTO не только в заполнении, но и в том, что DTO должно передавать валидные данные между слоями.

Value Object - Маленький объект для хранения величин таких как деньги или диапазон дат, равенство которых не основано на идентичности.
Value Object — это иммутабельный тип, значение которого задается при создании и не меняется на протяжении всей жизни объекта. Не имеет идентификатора. Если два VO структурно одинаковы — они эквивалентны.


10  ======== ======== ======== 

ORM:
- что такое ORM
- рассказать про 2 паттерна, 2 подхода и про Query Builder
- привести пример CRUD: Eloquent, Query Builder
(т.е есть сущность Article (поля придумайте сами)
какой код будет для создания, обновления, чтения, удаления
привести простые примеры через Eloquent и Query Builder)

Object Relational Mapping (объектно-реляционное отображение), обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных. С помощью ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL, и, в итоге, с меньшим суммарным кодом для доступа в базу данных.

Active Record и Data mapper это паттерны
Eloquent, Doctrine это библиотеки которые реализуют эти паттерны, являются ORM

Active Record — этот шаблон проектирования представляет запись из базы данных в виде объекта. Главная особенность — простота использования, так как колонки в базе данных являются полями (свойствами, атрибутами, кому как нравится) объекта и легко понять что с ними нужно делать.
Cвязь объектов с базой данных жесткая и неразрывная

Шаблон проектирования Data Mapper является прослойкой между сущностью и хранилищем данных. Он служит для облегчения сущности путем взятия на себя ответственности по работе с хранилищем данных. Другими словами, при использовании Data Mapper сущность
(пользователь, заказ, проект и т.д.) работает только со своими данными и бизнес-логикой, а сохранять, обновлять и удалять её будет другая часть системы.

Query Builder - конструктор запросов - предоставляет удобный, выразительный интерфейс для создания и выполнения запросов к базе данных. Он может использоваться для выполнения большинства типов операций и работает со всеми поддерживаемыми СУБД.

«Database First» — т.е. мы вначале проектируем схему БД
Code First

$car = new Car;
$car->name = "Машина 1 модель 5";
$car->save();

READ:
$car = Car::find(1);
$car = Car::where('id', 1)->get();
$car = Car::where('id', 1)->where('name', 'Имя машины')->get();
$cars= Car::all();

UPDATE:
$car = Car::find(1);
$car->name = "Машина 1 модель 6";
$car->save();

DELETE:
$car = Car::find(1);
$car->delete();

Car::destroy(1);


CREATE:
DB::table('users')->insert([
['email' => 'picard@example.com', 'votes' => 0],
['email' => 'janeway@example.com', 'votes' => 0],
]);

UPDATE:
DB::table('users')->where('id', 1)->update(['votes' => 1]);

DELETE:
$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();


11  ======== ======== ======== 

Привести примеры связи:
- один к одному
- один ко многим
- многие ко многим
- рассказать про проблему N+1, как фреймворк решает эту проблему


Eloquent · Отношения
Один к одному
users
id - integer
name - string

phones
id - integer
user_id - integer
number - string

class User extends Model
{
public function phone()
{
return $this->hasOne(Phone::class, 'user_id', 'id');
}
}
class Phone extends Model // user_id
{
public function user()
{
return $this->belongsTo(User::class, 'user_id', 'id');
//return $this->belongsTo(User::class, 'foreign_key');
}
}
$user = User::find(1)
$user->phone
$phone = Phone::find(1)
$phone->user



Один ко многим
class Post extends Model
{
public function comments()
{
return $this->hasMany(Comment::class);
}
}
class Comment extends Model
{

public function post()
{
return $this->belongsTo(Post::class);
}
}
posts
id - integer
name - string

comments
id - integer
post_id - integer
text - string

$post = Post::find(1)
$post->comments()->where('id', 5)
$post->comments


Многие ко многим
class User extends Model
{
public function roles()
{
return $this->belongsToMany(Role::class);
}
}
class Role extends Model
{
public function users()
{
return $this->belongsToMany(User::class);
}
}
users
id - integer
name - string

roles
id - integer
name - string

role_user
user_id - integer
role_id - integer


При доступе к отношениям Eloquent как к свойствам, связанные модели загружаются «отложенно». Это означает, что данные отношения фактически не загружаются, пока вы впервые не затребуете доступ к свойству. Однако Eloquent может «жадно» загрузить отношения во время запроса родительской модели. Жадная загрузка позволяет избежать проблем «N+1» с запросами.


12  ======== ======== ======== 

Что такое миграции и seeding, зачем нужны внешние ключи, рассказать про Soft Delete.

Миграции — системы контроля версий для вашей базы данных.
Seeding - простой механизм наполнения вашей БД начальными
Внешние ключи, это про ограничения целостности данных
это ссылочная целостность, post не может быть создан без категории, если при создании поста, указываем не существующую Id категорию, то будет ошибка в БД

Помимо фактического удаления записей из БД, Eloquent может также выполнять «мягкое удаление» модели. При таком удалении, они фактически не удаляются из БД. Вместо этого для модели устанавливается атрибут deleted_at, указывающий дату и время, когда модель была «удалена».


ON DELETE RESTRICT
означает, что если попробовать удалить категорию, у которого в таблице посты есть данные, БД не даст этого сделать:
Cannot
delete or update a parent row: a foreign key constraint fails

ON DELETE CASCADE
при удалении категории, удаляются все связанным с ним посты

ON UPDATE CASCADE, если изменится id категории, то в постах авт. изменится category_id
ON UPDATE RESTRICT, запрещаем изменения


13  ======== ======== ======== 
Аутентификация-aвторизация:
- что такое аутентификация
- что такое авторизация
- как фреймворк реализует авторизацию (т.е что фреймворк предоставляет чтоб разработчики могли настроить авторизацию)
- типы аутентификации

Аутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных
Авторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий

Laravel предлагает два основных способа авторизации действий: шлюзы и политики. Думайте о шлюзах и политиках, как о маршрутах и контроллерах. Шлюзы обеспечивают простой подход к авторизации, основанный на замыкании, в то время как политики, также как контроллеры, группируют логику вокруг конкретной модели или ресурса.

Basic Auth
Bearer Auth
JWT
Session Auth
Cookie Auth


16  ======== ======== ======== 
Тесты:
- 3 типа тестов, привести пример
- что такое честность и хрупкость
- основные шаги при тестировании
- 5 видов заменимых объектов, test doubles, для каких сценариев их лучше использовать

e2e - функциональные тесты (приёмочное)
Тестирует систему как если бы ей пользовался пользователь. Проверяет приложение на соответствие функциональным требованиям.

Интеграционные тесты
Тестирует взаимодействия нескольких модулей.

Unit тесты
Тестируют один конкретный модуль.

Честность - падение нашего теста, указывает нам на проблемы именно модуля который он тестирует, проблемы в любых других модулях не должны приводить к падению нашего теста.

Тестировать мы можем только то что наш модуль предоставляет наружу, рефакторинг модуля А при котором внешнее поведение сохраняется, не приводит к падению теста.

- Arrange - Подготовка
- Act - Выполнение
- Assert - Проверка

5 видов заменимых объектов
### Dummy
например модулю нужен объект конфигурации, можно подсунуть в Dummy пустой конфиг.
### Fake
фейковые объекты, содержат в себе логику, только они как-то ее упрощают.
### Stub
заглушка, просто содержит набор правил, когда вызывается метод, возвращает заранее известные данные. Cодержит набор правил как отвечать
### Spy
внутри себя отслеживает какое-то состояние, например сколько раз была отправлена почта
### Mocks
заглушка, которая содержит ожидания, о том с какими параметрами она будет вызвана


17  ======== ======== ======== 
Безопасность:
- перечислить HTTP заголовки которые защитят от XSS
- правило для предотвращения XSS
- правило для предотвращения SQL инъекций

Если отправляем данные в sql, то используем подготовленные запросы и плейсхолдер.
если отправляем данные в html (в шаблон), то используем экранирование

Content-Security-Policy
X-XSS-Protection: 1; mode=block