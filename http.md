# Жизненный цикл HTTP-запроса

HyperText Transer Protocol

http - протокол который придумали для передачи текста (бин. формат)

Клиент серверная архитектура

## Запрос страницы сайта

![alt](https://i.gyazo.com/ac6e0409e9dc2b35ce523e2490a95f9c.png)

Клиент обращается к серверу, запрашивает информацию, сервер возвращает информацию, запрос - ответ

## ip resolving

если заходим не по ip адресу, а по имени

например,

curl http://example.com

как клиент может определить ip адрес компьютера на котором лежит сайт example.com ?

запускается процесс - ip resolving

процесс определения ip адреса устройства по доменному имени сайта

локальный справочник адресов: /etc/hosts

127.0.0.1 localhost - служебный адрес, который всегда ведет на тот комп. на котором мы находимся

![alt](https://i.gyazo.com/2f8fb6ca765074c6c0573f0b93c539c0.png)

## DNS - domain name system

Главная справочная служба которая содержит соответсвия доменных имен с их ip адресами

![alt](https://i.gyazo.com/8b3a9b1b428ac18ade82f6184ba5b421.png)

https://www.lifewire.com/free-and-public-dns-servers-2626062

DNS - иерархическая, т.к домены могут быть в несколько уровней

```
.
.com.
example.com.
mail.example.com.
```

на самом вверху находится сервер котрый отвечает за все остальные зоны

![alt](https://i.gyazo.com/f1174482b7163a58ea19b6b33572b8a7.png)

cначала идет обращается к корню, потом к след. уровню .com и потом к след. уровню, например google, у домена google могут быть др. поддомены, например mail

## Кеширование ip адресов

у DNS могут быть скольо угодно вспомогательных серверов, т.е вмсто прямого обращения с корневому серверу, можно обратится к промежуточному серверу, который потом обратится к корневому (их много и они могут кешировать резульат на опред. время) - чтоб снизить нагрузку на корн. сервер

## Виртуальные порты

для разделение процессов в пределах одного комьютера, используется система виртуальных портов, которыми управляет ОС

![alt](https://i.gyazo.com/c62e5dd3f249655b088e6a8824914f4b.png)

помимо ip адреса компютера, ОС может предоставлять некоторые номера портов, который мы можем использовать в разных процессах, 1 .... до 65535,

привязка уникальная, процесс может забронировать несколько номеров

можно обратится по этому процессу, по id адресу и порту, например, http://example.com:666

при обращению к сайтам порты обычно не указываются, а используются по умолчанию

http - 80 порт

https - 443 порт


если есть порты на сервере, то есть порты и на клиенте, вся работа с сетью производится через них

если curl хочет работать с сетью, то curl тоже у ОС должен запросить порт, на сервере порт фиксированный, на клиенте, фикс. порт не нужен, curl может запросить любой свободный

![alt](https://i.gyazo.com/dff7d49d040addf8c2b8ffdf3ba5ee7a.png)

## Установка соединения

перед отправкой данных, происходит процесс установки соединения, для этого клиент отправляет пакеты которые содержит информацию о получателе и об отправители

![alt](https://i.gyazo.com/0747bcd596c0e72d64a603ca8fe0fa3e.png)

т.е указывается ip адреса сервера и его порт и указываетя ip адрес клиента и его порт, и если сервер получил запрос на подключение, то он на обратный адрес который указан в этом пакете отправляет сообщение что он готов подключится

и так м\у 2 комп. происходит процесс рукопожатия, когда они обмениваются служебными сообщениями

после такого запроса соедниение считается установленным и этот канал можно использовать для передачи основных сообщений

запрос попадает на сервер, он его парсит, производит обработку и генерирует ответ

после ответа отправляет обратно на клиент

после завершения сеанса общения, curl может разорвать соединение и попросить ОС отвязать от порта и завершить работу

зарезирвированный порт для curl, ОС освобожадет не сразу

## HTTP работает по прнципу одноразовых запросов и ответов

HTTP/1.0 - открывыает соедиение, запрашивает данные, получает данные, после этого соединение разрывается

но если на веб странице есть изображения, нужно их подгрузить, если например 10 изображений, то будет открыто 10 новых портов и произведется загрузка изображений (потом порты закроются)

проблема: каждый раз происходит процесс рукопожатия

HTTP/1.1 (оптимизированный) - используется одно и тоже подключение для последовательной отправки нескольких запросов

## HTTP/2

Проблему потери времени при последовательной загрузки файлов, решили в версии http2

Вместо простого текста теперь можно передавать запросы и ответы в более оптимальном бинарном формате и дали возможность мультиплексировать запросы

Мультиплексирование — это одно TCP-соединение для нескольких запросов и ответов.

![alt](https://i.gyazo.com/df972e42485ba9ed832562121d521436.png)

Однако мультиплексация ведёт к другой краеугольной проблеме. Представьте, что мы асинхронно выполняем 5 запросов к одному серверу. При использовании HTTP/2 все эти запросы будут выполняться в рамках одного TCP-соединения, а значит, если один из сегментов любого запроса потеряется или придёт неверно, передача всех запросов и ответов остановится, пока не будет восстановлен потерявшийся сегмент. Очевидно, что чем хуже качество соединения, тем медленнее работает HTTP/2. По оценке Дениела Стенберга, в условиях, когда потерянные пакеты составляют 2% от всех, HTTP/1.1 в браузере показывает себя лучше, чем HTTP/2 за счёт того, что открывает 6 соединений, а не одно.

## HTTP/3

HTTP/3 основан на протоколе QUIC (произносится «квик») — сокращённое от Quick UDP Internet Connections, быстрое подключение к интернету через UDP. Он мультиплексирует несколько потоков данных поверх UDP, то есть по умолчанию обеспечивает безопасность передачи данных.

Главное преимущество — уменьшение задержки при установлении соединения. QUIC достаточно одного «рукопожатия», чтобы установить безопасный сеанс. После установки первого соединения между сервером и клиентом новое рукопожатие больше не понадобится.

Мультиплексирование без блокировки HOL - при использовании нескольких потоков потерянные пакеты, несущие данные для отдельного потока, влияют только на этот конкретный поток. Таким образом, QUIC значительно снижает блокировку HOL.

HTTP (HOL) проблема с Head of Line Blocking. Это то, что происходит, когда клиент запрашивает несколько ресурсов и один ресурс застревает из-за задержки предыдущего большого. Возникает очередь запросов и отложенная отправка запросов на клиенте. Этому мешает ещё и строгий порядок ответов на сервере.

Когда один (медленный) объект мешает другим/следующим объектам двигаться.

![alt](https://i.gyazo.com/6632af49f513af612d2c613065529647.png)


# HTTP - Особенности  и Недостатки

## Особенности

- Клиент и сервер знают о наличии друг друга только во время соединения. После разрыва соединения они как бы забывают друг о друге. И при следующем соединении общаются словно в первый раз.
- Из этого следует, что HTTP не имеет состояния (stateless), так как не поддерживает постоянное соединение.
- HTTP не зависит от носителя. По HTTP может быть отправлен любой тип данных, если и клиент и сервер знают, как обрабатывать его содержимое.
- HTTP загружает отдельные элементы при помощи нескольких соединений.
- HTTP не содержит информацию о том, когда необходимо закрыть соединение (но есть заголовки, позволяющие это сделать).

## Недостатки

- Данные передаются в формате текста, поэтому хакерам легко их получить и использовать в своих целях.
- HTTP не имеет состояния, поэтому ни клиент, ни сервер не могут сохранять информацию между различными запросами.
- При HTTP браузеры приоритизируют загружаемые ресурсы, создавая очередь на клиенте и предположения о том, как наилучшим образом использовать доступные TCP-соединения. Это задерживает отправку запросов.
- Параллельная загрузка ресурсов ограничена количеством подключений. На практике это около шести подключений.
- HTTP (HOL) проблема с Head of Line Blocking.
- Заголовки не сжимаются, поэтому в веб-приложениях с большим количеством запросов скорость загрузки будет больше.
- Открытие нескольких TCP-соединений для запроса нескольких ресурсов.

# HTTP/2 - Особенности  и Недостатки


## Особенности

- HTTP-сообщения разбиваются на один или несколько фреймов с общим заголовком. Это сокращает дополнительное время приёма-передачи (RTT), ускоряя загрузку сайта без какой-либо оптимизации.
- Заголовки сжимаются при помощи алгоритма HPACK. Происходит сокращение информации для обмена между браузером и сервером.
- HTTP/2 мультиплексирован.
- Параллельный запрос статических элементов:

![alt](https://i.gyazo.com/2c3c7c96ec0f241ab235a8ae6a287cc8.png)

- Реализован push-сервер — возможность сервера отправлять несколько ответов на один клиентский запрос.
- Это бинарный протокол, а не текстовый, как HTTP/1, что устраняет проблемы безопасности, связанные с передачей текста в HTTP.
- Улучшен процесс распределения приоритетов, то есть браузеру отдаются сначала наиболее важные файлы (resource hinting: link rel=preload)
- Менее подвержен ошибкам и занимает меньше места в сети.
- HTTP/2 подразумевает использование веб-приложением безопасного HTTPS-соединения
- Все ресурсы сохраняются в кеше.

## Недостатки

- Блокировка заголовка на уровне TCP по-прежнему вызывает проблемы. Это значительно улучшено протоколом HTTP/3.
- Каждое соединение требует больших объёмов памяти по сравнению с HTTP.
- Не всегда нужно использовать безопасное соединение.
- Использование одновременных запросов увеличивает нагрузку на сервер, что приводит к тайм-аутам запросов.


# Различия между HTTP/2 и HTTP/3

![alt](https://i.gyazo.com/f1ff2970f78179d7382a23098e61f128.png)



# Misc

https://habr.com/ru/company/dododev/blog/473930/
https://habr.com/ru/post/308846/

https://habr.com/ru/company/selectel/blog/532868/

http://www.http2demo.io/
