# Жизненный цикл HTTP-запроса

HyperText Transfer Protocol

http - протокол который придумали для передачи текста (бин. формат)

Клиент серверная архитектура

## Запрос страницы сайта

![alt](https://i.gyazo.com/ac6e0409e9dc2b35ce523e2490a95f9c.png)

Клиент обращается к серверу, запрашивает информацию, сервер возвращает информацию, запрос - ответ

## ip resolving

если заходим не по ip адресу, а по имени

например,

curl http://example.com

как клиент может определить ip адрес компьютера на котором лежит сайт example.com ?

запускается процесс - ip resolving

процесс определения ip адреса устройства по доменному имени сайта

локальный справочник адресов: /etc/hosts

127.0.0.1 localhost - служебный адрес, который всегда ведет на тот комп. на котором мы находимся

![alt](https://i.gyazo.com/2f8fb6ca765074c6c0573f0b93c539c0.png)

## DNS - domain name system

DNS (Domain Name System) — это иерархическая децентрализованная система имен, используемая для преобразования удобных для человека доменных имен (например, www.example.com) в IP-адреса, понятные машинам (например, 192.0.2.44), которые используются для маршрутизации коммуникаций в сети Интернет. Процесс работы DNS включает несколько ключевых этапов и участников, включая корневые серверы DNS, серверы доменных имен верхнего уровня (TLD), авторитативные серверы и рекурсивные серверы.

https://powerdmarc.com/ru/authoritative-vs-recursive-dns/

Корневые серверы DNS — это основа системы доменных имен, поскольку они хранят информацию о серверах доменов верхнего уровня (TLD), таких как .com, .net, .org, .gov, .ru и т. д. Всего в мире насчитывается 13 корневых серверов, обозначенных буквами от A до M. На самом деле, каждый из этих 13 "серверов" представляет собой сеть из множества серверов, размещенных по всему миру для обеспечения устойчивости и надежности системы.

Главная справочная служба которая содержит соответсвия доменных имен с их ip адресами

![alt](https://i.gyazo.com/8b3a9b1b428ac18ade82f6184ba5b421.png)

https://www.lifewire.com/free-and-public-dns-servers-2626062

DNS - иерархическая, т.к домены могут быть в несколько уровней

```
.
.com.
example.com.
mail.example.com.
```

на самом вверху находится сервер котрый отвечает за все остальные зоны

![alt](https://i.gyazo.com/f1174482b7163a58ea19b6b33572b8a7.png)

cначала идет обращается к корню, потом к след. уровню .com и потом к след. уровню, например google, у домена google могут быть др. поддомены, например mail


Цепочка определения IP-адреса на основе домена при использовании DNS-сервера от Google:

Пользовательский запрос: Когда пользователь вводит доменное имя в браузер, система сначала проверяет, не сохранен ли IP-адрес этого домена в локальном кэше. (или в etc hosts) Если адрес не найден, запрос отправляется на DNS-сервер, указанный в настройках сети пользователя, в данном случае на сервер Google (8.8.8.8).

Запрос к корневому серверу: Если запрашиваемый адрес не найден в кэше Google DNS, сервер выполняет запрос к одному из корневых DNS-серверов для получения информации о сервере доменов верхнего уровня (TLD) для данного домена.

https://root-servers.org/

Запрос к серверу TLD: С информацией от корневого сервера Google DNS теперь отправляет запрос к соответствующему серверу TLD (например, для доменов .com) для получения адреса авторитативного DNS-сервера домена.

Запрос к авторитативному серверу: Затем Google DNS обращается к авторитативному DNS-серверу домена, запрашивая IP-адрес ассоциированный с доменным именем.

Возврат ответа пользователю: Получив IP-адрес от авторитативного сервера, Google DNS передает этот адрес обратно в браузер пользователя. Браузер затем использует этот IP-адрес для установления соединения с веб-сервером, на котором размещен сайт, и начинает процесс загрузки страницы.

Авторитетные DNS-серверы содержат авторитетные записи для конкретных доменов, выступая в качестве опорных точек для IP-адресов и других данных DNS.

Каждый раз, когда вводится доменное имя в браузер, система DNS через серию запросов и ответов преобразует это имя в IP-адрес, позволяя  браузеру загружать нужный веб-сайт. Этот процесс обычно занимает всего несколько миллисекунд.


## Кеширование ip адресов

у DNS могут быть сколько угодно вспомогательных серверов, т.е вместо прямого обращения к корневому серверу, можно обратится к промежуточному серверу, который потом обратится к корневому (их много и они могут кешировать результат на опред. время) - чтоб снизить нагрузку на корн. сервер

## Виртуальные порты

для разделение процессов в пределах одного комьютера, используется система виртуальных портов, которыми управляет ОС

![alt](https://i.gyazo.com/c62e5dd3f249655b088e6a8824914f4b.png)

помимо ip адреса компютера, ОС может предоставлять некоторые номера портов, который мы можем использовать в разных процессах, 1 .... до 65535,

привязка уникальная, процесс может забронировать несколько номеров

можно обратится по этому процессу, по id адресу и порту, например, http://example.com:666

при обращению к сайтам порты обычно не указываются, а используются по умолчанию

http - 80 порт

https - 443 порт

если есть порты на сервере, то есть порты и на клиенте, вся работа с сетью производится через них

если curl хочет работать с сетью, то curl тоже у ОС должен запросить порт, на сервере порт фиксированный, на клиенте, фикс. порт не нужен, curl может запросить любой свободный

![alt](https://i.gyazo.com/dff7d49d040addf8c2b8ffdf3ba5ee7a.png)

## Установка соединения

![alt](/images/cf6057a54f005a288d832d293965ee0d.svg)

перед отправкой данных, происходит процесс установки соединения, для этого клиент отправляет пакеты которые содержит информацию о получателе и об отправители

т.е указывается ip адреса сервера и его порт и указываетя ip адрес клиента и его порт, и если сервер получил запрос на подключение, то он на обратный адрес который указан в этом пакете отправляет сообщение что он готов подключится.

и так м\у 2 комп. происходит процесс рукопожатия, когда они обмениваются служебными сообщениями.

после такого запроса соедниение считается установленным и этот канал можно использовать для передачи основных сообщений

запрос попадает на сервер, он его парсит, производит обработку и генерирует ответ

после ответа отправляет обратно на клиент

### SYN (Synchronize)

Назначение: Используется для инициации соединения между двумя хостами.

Процесс: Отправка пакета с флагом SYN от клиента к серверу начинает процесс установления соединения, сигнализируя о желании начать общение. В этом пакете клиент указывает свой начальный порядковый номер, который будет использоваться в последовательности передачи данных.

### ACK (Acknowledgment)

Назначение: Подтверждает получение пакета от отправителя.

Процесс: После получения SYN-пакета сервер отвечает пакетом, содержащим как флаги SYN, так и ACK. SYN здесь означает запрос на соединение с клиентом, а ACK подтверждает получение первоначального SYN-пакета от клиента. Затем клиент отправляет серверу ACK-пакет, подтверждая получение SYN-ACK от сервера и завершая таким образом трехэтапное рукопожатие TCP.

Этот процесс трехэтапного рукопожатия (SYN, SYN-ACK, ACK) создает надежное соединение между клиентом и сервером, что является предпосылкой для последующего обмена данными, например, HTTP-запросами и ответами.

В контексте HTTP, после установления TCP-соединения с использованием SYN и ACK, клиент может отправить HTTP-запрос, а сервер — HTTP-ответ. Это обеспечивает надежную основу для веб-коммуникаций, поскольку TCP гарантирует, что все пакеты будут доставлены в правильном порядке и без потерь.

# HTTP/1.*

HTTP работает по прнципу одноразовых запросов и ответов

![alt](/images/84cf0f29175e4b11a2343e73105637c5.svg)

HTTP/1.0 - открывает соедиение, запрашивает данные, получает данные, после этого соединение разрывается

но если на веб странице есть изображения, нужно их подгрузить, если например 10 изображений, то будет открыто 10 новых портов и произведется загрузка изображений (потом порты закроются)

проблема: каждый раз происходит процесс рукопожатия

![alt](/images/cf6057a54f005a288d832d293965ee0d.svg)

HTTP/1.1 (оптимизированный) - используется одно и тоже подключение для последовательной отправки нескольких запросов

## Особенности

- Клиент и сервер знают о наличии друг друга только во время соединения. После разрыва соединения они как бы забывают друг о друге. И при следующем соединении общаются словно в первый раз.
- Из этого следует, что HTTP не имеет состояния (stateless), так как не поддерживает постоянное соединение.
- HTTP не зависит от носителя. По HTTP может быть отправлен любой тип данных, если и клиент и сервер знают, как обрабатывать его содержимое.
- HTTP загружает отдельные элементы при помощи нескольких соединений.
- HTTP не содержит информацию о том, когда необходимо закрыть соединение (но есть заголовки, позволяющие это сделать).

## Недостатки

- Данные передаются в формате текста, поэтому хакерам легко их получить и использовать в своих целях.
- HTTP не имеет состояния, поэтому ни клиент, ни сервер не могут сохранять информацию между различными запросами.
- При HTTP браузеры приоритизируют загружаемые ресурсы, создавая очередь на клиенте и предположения о том, как наилучшим образом использовать доступные TCP-соединения. Это задерживает отправку запросов.
- Параллельная загрузка ресурсов ограничена количеством подключений. На практике это около шести подключений.
- HTTP (HOL) проблема с Head of Line Blocking.
- Заголовки не сжимаются, поэтому в веб-приложениях с большим количеством запросов скорость загрузки будет больше.
- Открытие нескольких TCP-соединений для запроса нескольких ресурсов.

HTTP (HOL) проблема с Head of Line Blocking. Это то, что происходит, когда клиент запрашивает несколько ресурсов и один ресурс застревает из-за задержки предыдущего большого. Возникает очередь запросов и отложенная отправка запросов на клиенте. Этому мешает ещё и строгий порядок ответов на сервере.

Когда один (медленный) объект мешает другим/следующим объектам двигаться.

# HTTP/2

Проблему потери времени при последовательной загрузки файлов, решили в версии http2

Вместо простого текста теперь можно передавать запросы и ответы в более оптимальном бинарном формате и дали возможность мультиплексировать запросы

Мультиплексирование — это одно TCP-соединение для нескольких запросов и ответов.

![alt](https://i.gyazo.com/df972e42485ba9ed832562121d521436.png)

Мультиплексирование запросов: Браузер отправляет запросы за различными ресурсами веб-страницы (например, за изображениями, CSS-файлами, JavaScript) через одно и то же HTTP/2 соединение, используя мультиплексирование.

Однако мультиплексация ведёт к другой краеугольной проблеме. Представьте, что мы асинхронно выполняем 5 запросов к одному серверу. При использовании HTTP/2 все эти запросы будут выполняться в рамках одного TCP-соединения, а значит, если один из сегментов любого запроса потеряется или придёт неверно, передача всех запросов и ответов остановится, пока не будет восстановлен потерявшийся сегмент. Очевидно, что чем хуже качество соединения, тем медленнее работает HTTP/2. По оценке Дениела Стенберга, в условиях, когда потерянные пакеты составляют 2% от всех, HTTP/1.1 в браузере показывает себя лучше, чем HTTP/2 за счёт того, что открывает 6 соединений, а не одно.

## Особенности

- HTTP-сообщения разбиваются на один или несколько фреймов с общим заголовком. Это сокращает дополнительное время приёма-передачи (RTT), ускоряя загрузку сайта без какой-либо оптимизации.
- Заголовки сжимаются при помощи алгоритма HPACK. Происходит сокращение информации для обмена между браузером и сервером.
- HTTP/2 мультиплексирован.
- Параллельный запрос статических элементов:

![alt](https://i.gyazo.com/2c3c7c96ec0f241ab235a8ae6a287cc8.png)

- Реализован push-сервер — возможность сервера отправлять несколько ответов на один клиентский запрос.
- Это бинарный протокол, а не текстовый, как HTTP/1, что устраняет проблемы безопасности, связанные с передачей текста в HTTP.
- Улучшен процесс распределения приоритетов, то есть браузеру отдаются сначала наиболее важные файлы (resource hinting: link rel=preload)
- Менее подвержен ошибкам и занимает меньше места в сети.
- HTTP/2 подразумевает использование веб-приложением безопасного HTTPS-соединения

## Недостатки

- Блокировка заголовка на уровне TCP по-прежнему вызывает проблемы. Это значительно улучшено протоколом HTTP/3.
- Каждое соединение требует больших объёмов памяти по сравнению с HTTP.
- Не всегда нужно использовать безопасное соединение.
- Использование одновременных запросов увеличивает нагрузку на сервер, что приводит к тайм-аутам запросов.

# TCP VS UDP

TCP (Transmission Control Protocol) и UDP (User Datagram Protocol)

| **Характеристика** | **TCP** | **UDP** |
| --- | --- | --- |
| **Ориентация** | Соединение (подтверждение установки соединения перед передачей данных) | Без соединения (данные передаются без предварительного установления соединения) |
| **Надежность** | Высокая (автоматическое повторное отправление потерянных пакетов, проверка порядка пакетов) | Низкая (отсутствие механизмов для обеспечения доставки или порядка пакетов) |
| **Скорость передачи** | Медленнее из-за механизмов управления и проверок | Быстрее за счет отсутствия механизмов управления и проверок |
| **Использование** | Приложения, требующие надежной доставки данных (веб-браузеры, передача файлов, электронная почта) | Приложения, требующие быстрой доставки и готовые терпеть потери данных (стриминг видео и аудио, онлайн-игры, VoIP) |

UDP: Я знаю отличную шутку про UDP, но не факт, что она до вас дойдет.

TCP: Я знаю отличную шутку про TCP, но если она до вас не дойдет, то я повторю.


# HTTP/3

HTTP/3 основан на протоколе QUIC (произносится «квик») — сокращённое от Quick UDP Internet Connections, быстрое подключение к интернету через UDP. Он мультиплексирует несколько потоков данных поверх UDP, то есть по умолчанию обеспечивает безопасность передачи данных.

Главное преимущество — уменьшение задержки при установлении соединения. QUIC достаточно одного «рукопожатия», чтобы установить безопасный сеанс. После установки первого соединения между сервером и клиентом новое рукопожатие больше не понадобится.

Мультиплексирование без блокировки HOL - при использовании нескольких потоков потерянные пакеты, несущие данные для отдельного потока, влияют только на этот конкретный поток. Таким образом, QUIC значительно снижает блокировку HOL.


![alt](https://i.gyazo.com/6632af49f513af612d2c613065529647.png)


## Различия между HTTP/2 и HTTP/3

![alt](https://i.gyazo.com/f1ff2970f78179d7382a23098e61f128.png)



# TLS handshake

![alt](/images/How_does_HTTPS_work.png)

Перед тем, как начать обмен данными через TLS, клиент и сервер должны согласовать параметры соединения, а именно: версия используемого протокола, способ шифрования данных, а также проверить сертификаты, если это необходимо.

Браузер и сервер взаимодействуют по протоколу HTTPS с помощью процедуры, называемой TLS (Transport Layer Security) handshake.

Во время TLS handshake происходит обмен публичными ключами. Этот процесс происходит следующим образом:

1. Браузер отправляет запрос на сервер и указывает, что хочет использовать HTTPS.
2. Сервер отправляет свой сертификат браузеру, который содержит его публичный ключ и подтверждение его личности.
3. Браузер проверяет сертификат сервера, убеждается в его валидности и извлекает публичный ключ сервера.
4. Браузер генерирует сеансовый ключ (session key) и зашифровывает его публичным ключом сервера.
5. Сервер использует свой приватный ключ для расшифровки сеансового ключа.
6. Теперь браузер и сервер могут использовать сеансовый ключ для защищенного обмена данных по протоколу HTTPS.

Этот обмен публичными ключами позволяет браузеру и серверу установить защищенное соединение и обеспечить конфиденциальность и целостность передаваемых данных.


# Misc

http://www.http2demo.io/


# IDN и Перекодировка URL

ASCII  — стандарт кодирования знаков латинского алфавита, цифр, некоторых специальных знаков и управляющих последовательностей, принятый в 1963 году Американской ассоциацией стандартов как основной способ представления текстовых данных в ЭВМ

Punycode — стандартизированный метод преобразования последовательностей Unicode-символов в так называемые ACE-последовательности, которые состоят только из алфавитно-цифровых символов, как это разрешено в доменных именах.

## Интернационализированные доменные имена (IDN)

Для поддержки кириллицы и других не-ASCII символов в доменных именах были разработаны интернационализированные доменные имена (IDN). IDN позволяют использовать широкий диапазон символов, включая кириллицу, иероглифы и другие скрипты. Для совместимости с существующей DNS-системой, которая поддерживает только ASCII, эти имена преобразуются в формат Punycode, начинающийся с префикса "xn--". Например, доменное имя "пример.рф" в Punycode будет представлено как "xn--e1afmkfd.xn--p1ai".

## Перекодировка URL

Для включения кириллических и других не-ASCII символов в части URL, кроме доменного имени, используется процентное кодирование (percent-encoding), где символы кодируются в виде % за которым следуют две шестнадцатеричные цифры, представляющие код символа в кодировке UTF-8. Например, адрес "http://пример.рф/путь" будет закодирован как "http://xn--e1afmkfd.xn--p1ai/%D0%BF%D1%83%D1%82%D1%8C".
