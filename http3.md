# Состояние: Cookies и сессии

Cookies (куки) — это механизм протокола HTTP, используемый для хранения данных браузером. Они позволяют отслеживать или идентифицировать возвращающихся посетителей. По сути, единственный надёжный способ понять что перед нами тот же самый пользователь.

Именно благодаря кукам, гугл узнает вас и преследует рекламой того, что вы недавно искали, на сайтах, которые вроде бы не должны знать о ваших предпочтениях.

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.


Куки часто используются для:

- Управления сеансом (логины, корзины для виртуальных покупок)
- Персонализации (пользовательские предпочтения)
- Трекинга (отслеживания поведения пользователей)

## Параметры:

path - URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.

domain - Домен определяет, где доступен файл куки. (*.site.com)

expires, max-age - По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными («session cookies»).

secure - Куки следует передавать только по HTTPS-протоколу.

httpOnly - Эта настройка запрещает любой доступ к куки из JavaScript.

samesite используется браузерами для определения того, как следует обрабатывать основные и сторонние файлы cookie. Браузеры могут разрешать или блокировать такие файлы cookie в зависимости от атрибута и сценария.

samesite=strict - Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта.

samesite=lax - Режим Lax так же, как и strict, запрещает браузеру отправлять куки, когда запрос происходит не с сайта, но добавляет одно исключение.

```
setcookie("key", "value", [
    'expires' => time(),
    'path' => '/',
    'domain' => '',
    'secure' => true,
    'httpOnly' => true,
    'samesite' => 'lax'
]);
```

# Сессии

Сессия, это абстракция, созданная для удобной работы с индивидуальными пользователями. Она используется для идентификации пользователей и позволяет отличать их друг от друга. Например, аутентификация на сайтах построена поверх механизма сессии.

Сессии реализуются на уровне конкретных фреймворков и только в PHP сессии встроены в язык. Общий принцип работы сессии сводится к трём операциям:

- Старт сессии. Так мы говорим системе, что хотим начать следить за пользователем. Во многих фреймворках эта операция выполняется неявно, при попытке чтения или записи в сессию.
- Запись данных в сессию.
- Чтение данных из сессии.

Старт сессии на техническом уровне означает установку специальной куки в браузер. Обычно эта кука содержит идентификатор сессии, который уникален для каждого пользователя. Данные сессии могут храниться где угодно, это зависит от конкретной реализации. В этом одно из ключевых отличий работы с пользователями напрямую через куки или через сессию. Сессия более высокоуровневая абстракция.

Работая с сессией не надо думать про имена кук, про сериализацию и десериализацию составных данных. Всё это происходит автоматически.

Сама сессия представляет собой структуру данных на сервере (может храниться в виде файла, в базе данных, в памяти или другими способами).

# Архитектура для http

Чистая архитектура для http, полное разделение пользователей др. от друга

![alt](https://i.gyazo.com/aff55c49789c01ecfac201c2a5ce93c9.png)

![alt](https://i.gyazo.com/e8ebf6876ca1c57b9409d1d643f9963f.png)

![alt](https://i.gyazo.com/3950d4f157ba568d94938baa0e9dddb6.png)

# REST:

REST (Representational State Transfer)  — это способ создания API с помощью протокола HTTP.

На русском его называют «передачей состояния представления».

REST API — это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.

- Клиент серверная архитектура (HTTP)
- Stateless
- Кэширование
- Единообразие интерфейса
- Layered system

Stateless - не использование глобального состояния, глобального стейта на сервере

Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

Stateful - В этом случае сервер хранит информацию о предыдущих обращениях клиента, хранит информацию о сессии, какую-то часть контекста взаимодействия с клиентом. А затем может использовать эту информацию при обработке следующих запросов.

# Сохранение данных в браузере

![alt](https://i.gyazo.com/55ae1ebb0e8db062a1329fc1d9dbfd81.png)
![alt](https://i.gyazo.com/02b92bbe860f429e6b065ce8b4e81832.png)
![alt](https://i.gyazo.com/36f19cd4e2cd0fd6215b7450d6ba287c.png)
![alt](https://i.gyazo.com/0fb36aa344ffd8ec22d20ce5438f5086.png)


# Сессии

![alt](https://i.gyazo.com/133a9a35bc6e9fdaab574ba4ae5f6eb4.png)

![alt](https://i.gyazo.com/86a1d2a5fd103cb285c8a63d7c36c5f0.png)

![alt](https://i.gyazo.com/b9f4e5390c49fc493b45854c92b8f076.png)

# Аутентификации

Аутентификация — процедура проверки подлинности, например: проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользовательских логинов; подтверждение подлинности электронного письма путём проверки цифровой подписи письма по открытому ключу отправителя;

![alt](https://i.gyazo.com/2781b308e7e61d8b742ce83d54eae416.png)

![alt](https://i.gyazo.com/9eee1bf62b2e8505ea46f86fa0917de4.png)

## Basic Auth

![alt](https://i.gyazo.com/c10103cfdd47f26e14d8ea1b0bdc53f4.png)

```
<Directory "/var/www/html">
  AuthType Basic
  AuthName "Restricted Content"
  AuthUserFile /etc/apache2/.htpasswd
  Require valid-user
</Directory>
```

## Bearer Auth

![alt](https://i.gyazo.com/068485d9db7c8f8db6ca1282979abc68.png)

![alt](https://i.gyazo.com/31d803f57e86fa0c90c40544f09e2eba.png)

## JWT

Одним из принципов REST является независимость от состояния (stateless). Это значит, что клиент должен сам позаботиться о своей аутентификации при каждом запросе.

JWT состоит из трех основных частей: заголовка (header), нагрузки (payload) и подписи (signature). Заголовок и нагрузка формируются отдельно, а затем на их основе вычисляется подпись.

Header

Обычно заголовок состоит из двух полей: типа токена (в данном случае JWT) и алгоритма хэширования подписи:

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```


Payload — это любые данные, которые вы хотите передать в токене

```json
{
  "iss": "Codex Team",
  "sub": "auth",
  "exp": 1505467756869,
  "iat": 1505467152069,
  "user": 1
}
```

Payload не шифруется при использовании токена, поэтому не стоит передавать в нем данные, которые не должны попасть в открытый доступ.

Signature - Подпись вычисляется на основе заголовка и нагрузки. Таким образом, если кто-то попытается изменить данные в токене, он не сможет изменить подпись, не зная приватного ключа. При аутентификации приватным ключом может выступать пароль пользователя (или хеш от пароля).

https://jwt.io/


Refresh tokens

В современных схемах аутентификации, основанных на JWT, после прохождения аутентификации пользователь получает два токена:

- access token — JWT, на основе которого приложение идентифицирует и авторизует пользователя;
- refresh token — токен произвольного формата, служащий для обновления access token.

Access token при таком подходе имеет сильно ограниченное время жизни (например, одну минуту). Refresh token же имеет длительное время жизни (день, неделя, месяц), но он одноразовый и служит исключительно для обновления access token пользователя.

Схема аутентификации в таком случае выглядит следующим образом:

- пользователь проходит процедуру аутентификации и получает от сервера access token и refresh token;
- при обращении к ресурсу пользователь передает в запросе свой access token, на основе которого сервер идентифицирует и авторизует клиента;
- при истечении access token клиент передает в запросе свой refresh token и получает от сервера новые access token и refresh token;
- при истечении refresh token пользователь заново проходит процедуру аутентификации.


## Session Auth

![alt](https://i.gyazo.com/c10df3238beec8ea90f56115cb4fec60.png)

## Cookie Auth

![alt](https://i.gyazo.com/d9f4832f9f664ee1db17965f06df271e.png)


## OAuth 2

OAuth 2.0 — протокол авторизации, позволяющий выдать одному сервису (приложению) права на доступ к ресурсам пользователя на другом сервисе. Протокол избавляет от необходимости доверять приложению логин и пароль, а также позволяет выдавать ограниченный набор прав, а не все сразу.



![alt](https://i.gyazo.com/95c25857b7d05c0db447a70b1d0654c9.png)

https://codd-wd.ru/primery-realizacii-avtorizacii-oauth-2-0-vkontakte-na-php-i-javascript-vk-api/

https://dev.vk.com/api/access-token/authcode-flow-user

https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#authentication_schemes

# misc

![alt](https://i.gyazo.com/62bed6a55de83cfec1fc72d336bbbe22.png)

Statefull

- На клиенте только индентификатор
- Содержимое на сервере
- Легко отозвать
- Централизованное хранилище
- Хорошее observability (логи, видим содержимое сессий)

Stateless

- На клиенте все данные из сессий
- Просто так не отозвать
- Хорошо масштабируется
- Сложно расследовать инциденты постфактум
