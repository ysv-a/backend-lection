# Монолит и микросервисы

Монолитное приложение — это единый общий модуль, в то время как микросервисная архитектура представляет собой набор небольших независимо развертываемых служб.

# Модульный монолит

Модульный монолит — это архитектурный стиль, при котором приложение строится как единое целое, но с четким разделением на модули. Каждый модуль отвечает за свою часть функциональности и имеет четко определенные границы и интерфейсы для взаимодействия с другими модулями.

Основные преимущества модульного монолита:

- **Упрощенное управление зависимостями**: Модули могут быть четко изолированы друг от друга.
- **Легкость разработки и тестирования**: Модули можно разрабатывать и тестировать независимо.
- **Упрощенное развертывание**: В отличие от микросервисов, модульный монолит развертывается как единое приложение.
- **Производительность**: Взаимодействие между модулями происходит внутри одного процесса, что быстрее, чем межсервисное взаимодействие в микросервисах.

# Обычный монолит vs. Модульный монолит

**Обычный монолит** — это архитектурный стиль, при котором все компоненты приложения тесно связаны и развертываются как единое целое. В обычном монолите часто отсутствует четкое разделение на модули, что приводит к следующим проблемам:
- **Сложность управления зависимостями**: Изменения в одном компоненте могут повлиять на другие компоненты.
- **Трудности в масштабировании**: Масштабирование отдельных частей приложения затруднено.
- **Сложности в тестировании**: Тестирование отдельных компонентов может быть затруднено из-за тесной связи между ними.

**Модульный монолит** решает эти проблемы за счет четкого разделения на модули. Каждый модуль имеет свои границы и интерфейсы, что упрощает управление зависимостями и тестирование.

# Модульный монолит vs. Микросервисы

**Микросервисы** — это архитектурный стиль, при котором приложение строится как набор небольших, автономных сервисов, каждый из которых выполняет свою бизнес-логику и взаимодействует с другими сервисами через четко определенные интерфейсы, обычно через HTTP или сообщения.

Основные различия между модульным монолитом и микросервисами:
- **Развертывание**: Модульный монолит развертывается как единое приложение, в то время как микросервисы развертываются независимо друг от друга.
- **Взаимодействие**: В модульном монолите взаимодействие между модулями происходит внутри одного процесса, что быстрее и надежнее, чем межсервисное взаимодействие в микросервисах.
- **Масштабируемость**: Микросервисы можно масштабировать независимо друг от друга, в то время как масштабирование модульного монолита требует масштабирования всего приложения.
- **Управление зависимостями**: В модульном монолите управление зависимостями проще, так как все модули находятся в одной кодовой базе. В микросервисах управление зависимостями сложнее из-за распределенной природы системы.

Основные преимущества микросервисной архитектуры:
- **Масштабируемость**: Каждый сервис можно масштабировать независимо.
- **Гибкость разработки**: Разные команды могут работать над разными сервисами, используя различные технологии.
- **Устойчивость**: Отказ одного сервиса не приводит к отказу всего приложения.
- **Упрощение развертывания**: Микросервисы можно развертывать независимо друг от друга.

# Low Coupling - High Cohesion

Low Coupling (Зацепление ) - мера того, насколько взаимозависимы разные подпрограммы или модули

High Cohesion (Связность) — мера силы взаимосвязанности элементов внутри модуля; способ и степень, в которой задачи, выполняемые некоторым программным модулем, связаны друг с другом.

# Bounded Context

Bounded Context — это концепция из Domain-Driven Design (DDD), которая помогает разделить систему на логически изолированные области. Каждый Bounded Context имеет свои модели и логику, которые не пересекаются с другими контекстами.

Система декомпозируется на Bounded Context, которые становятся естественными границами — как микросервисы в коде и как команды в организации.


# Application Side Joins

Application Side Joins — это техника объединения данных из разных микросервисов на уровне приложения, а не базы данных. Это необходимо, когда данные распределены по разным сервисам и нет возможности выполнить SQL JOIN.

# Outbox Pattern (Transactional outbox)

Outbox Pattern используется для обеспечения надежной доставки сообщений между микросервисами. Идея заключается в том, чтобы записывать сообщения в "выходной ящик" (outbox) в той же транзакции, что и изменения в базе данных. Затем отдельный процесс читает сообщения из outbox и отправляет их в нужные сервисы.

Гарантии доставки сообщения:

At-most-once — может быть доставлено 0 или 1 раз.

At-least-once — может быть доставлено 1 или более раз (т.е. возможны дубликаты сообщения)

Exactly once — может быть доставлено строго один раз.

# Паттерн Saga

Шаблон распределенных транзакций Saga

Паттерн Distributed Saga —  это паттерн управления сбоями, где каждое действие имеет компенсирующее действие для отката. Распределенные саги помогают обеспечить согласованность и правильность микросервисов.

Паттерн Saga используется для управления распределенными транзакциями в микросервисной архитектуре. В отличие от традиционных ACID-транзакций, которые трудно реализовать в распределенных системах, Saga разбивает транзакцию на серию шагов, каждый из которых является локальной транзакцией.

Если на каком-то этапе происходит ошибка, необходимо откатить все предыдущие шаги.

В монолите используются транзакции, в распределенных системах используются Saga.

Пример:

Клиент хочет забронировать полный пакет путешествия, включающий рейс, отель и аренду автомобиля. В отсутствие распределенных транзакций могут возникнуть следующие проблемы:

Рейс забронирован, но бронирование отеля не удалось из-за отсутствия номеров. В результате клиент остается с забронированным рейсом, но без отеля.

Если один из микросервисов завершает свою операцию, а другой не успевает из-за сетевой ошибки, система может оказаться в непоследовательном состоянии.

В случае ошибки откат всех изменений вручную может быть сложным и подверженным ошибкам процессом.

Пример реализации Saga:

Saga разбивает глобальную транзакцию на серию локальных транзакций, каждая из которых выполняется в своем микросервисе. Если какой-либо шаг не удается, Saga выполняет компенсирующие действия для отмены предыдущих шагов.

**Начало**

Клиент отправляет запрос на бронирование полного пакета путешествия.**

**Шаг 1: Бронирование рейса**

Микросервис бронирования рейсов выполняет локальную транзакцию для бронирования рейса.

Если бронирование успешно, микросервис отправляет событие "FlightBooked".

**Шаг 2: Бронирование отеля:**

Микросервис бронирования отелей получает событие "FlightBooked" и выполняет локальную транзакцию для бронирования отеля.

Если бронирование успешно, микросервис отправляет событие "HotelBooked".

Если бронирование не удалось, микросервис отправляет событие "HotelBookingFailed".

**Шаг 3: Бронирование автомобиля:**

Микросервис бронирования автомобилей получает событие "HotelBooked" и выполняет локальную транзакцию для бронирования автомобиля.

Если бронирование успешно, микросервис отправляет событие "CarBooked".

Если бронирование не удалось, микросервис отправляет событие "CarBookingFailed".

**Компенсация**

Если любой из шагов не удается, Saga инициирует компенсирующие действия.

# ACID

ACID — это набор свойств, которые гарантируют надежность транзакций в системах управления базами данных (СУБД). Эти свойства важны для обеспечения целостности данных и корректного выполнения транзакций.

Atomicity (Атомарность) - транзакция должна быть выполнена полностью или не выполнена вовсе.

Consistency (Согласованность) - транзакция должна переводить базу данных из одного согласованного состояния в другое.

Isolation (Изолированность) - выполнение транзакции должно быть изолировано от других транзакций.

Durability (Долговечность) - после завершения транзакции ее результаты должны быть надежно сохранены в базе данных, даже в случае сбоя системы.

# Оркестрация и хореография

Два подхода к управлению взаимодействием между микросервисами в распределенных системах.

## Оркестрация

Оркестрация предполагает наличие центрального компонента, который управляет и координирует взаимодействие между микросервисами. Этот центральный компонент, называемый оркестратором, отвечает за вызов микросервисов в нужной последовательности и передачу данных между ними.

## Хореография

Хореография предполагает, что каждый микросервис самостоятельно реагирует на события и взаимодействует с другими микросервисами без центрального управления. В этом подходе микросервисы обмениваются событиями и выполняют действия на основе полученных событий.

# Паттерны интеграции микросервисов

https://habr.com/ru/companies/slurm/articles/679906/

https://habr.com/ru/companies/slurm/articles/681326/

## ACL

Anti-Corruption Layer (ACL) — это паттерн проектирования, который используется для изоляции и защиты внутренней модели домена от внешних систем или сервисов, которые могут иметь несовместимые или нежелательные модели данных и поведения. ACL действует как промежуточный слой, который переводит запросы и данные между внутренней системой и внешними системами, обеспечивая тем самым целостность и согласованность внутренней модели.


# EventStorming

![alt](https://eda-visuals.boyney.io/assets/visuals/eda/event-storming.png)

EventStorming — это методология моделирования бизнес-процессов и систем. Она используется для выявления и анализа событий, которые происходят в системе или бизнес-процессе, с целью лучшего понимания и улучшения этих процессов.

События (Events) — это ключевые моменты, которые происходят в системе или бизнес-процессе. Они обычно выражаются в прошедшем времени, например, "Заказ создан", "Платеж обработан".

Участники (Actors) — это люди или системы, которые взаимодействуют с процессом или системой. Они могут инициировать события или реагировать на них.

Команды (Commands) — это действия, которые инициируют события. Например, "Создать заказ", "Обработать платеж".

Агрегаты (Aggregates) — это группы связанных событий и команд, которые логически объединены. Они помогают структурировать модель и управлять сложностью.

Политики (Policies) — это правила или условия, которые определяют, как система должна реагировать на события. Например, "Если заказ не оплачен в течение 24 часов, отменить заказ".

Проекции (Projections) — это представления данных, которые используются для отображения информации пользователям или другим системам.

# Event Sourcing

Event Sourcing — это шаблон проектирования, который используется для построения систем, где состояние объекта или системы сохраняется как последовательность неизменяемых событий. В отличие от традиционных подходов, где текущее состояние объекта хранится в базе данных, Event Sourcing сохраняет все изменения состояния как отдельные события. Это позволяет легко восстанавливать состояние объекта на любой момент времени, а также предоставляет множество других преимуществ.

События (Events) представляют собой неизменяемые факты, которые произошли в системе. Они записываются в хронологическом порядке и содержат всю необходимую информацию для восстановления состояния системы.

Агрегаты (Aggregates) — это логические группы событий, которые представляют собой единицы консистентности и управления состоянием. Агрегаты обрабатывают команды и генерируют события.

Команды (Commands) — это запросы на изменение состояния системы. Они обрабатываются агрегатами, которые в свою очередь генерируют события.

Проекции (Projections) используются для создания представлений данных, которые удобны для чтения. Они строятся на основе событий и могут быть обновлены при появлении новых событий.

Хранилище событий (Event Store) — это база данных, которая сохраняет все события. Оно обеспечивает надежное и неизменяемое хранение событий.
