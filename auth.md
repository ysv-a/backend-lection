# Аутентификация

это процесс проверки подлинности пользователя, который пытается получить доступ к системе или приложению. В процессе аутентификации пользователь предоставляет данные для проверки, такие как логин и пароль, и система сверяет эти данные с хранящимся в базе данных. Если данные верны, то пользователь считается аутентифицированным и получает доступ к системе, в противном случае пользователь не будет авторизован и ему не будет разрешен доступ.

# Авторизация

это процесс предоставления пользователю доступа к определенным ресурсам или функциям системы после успешной аутентификации. Авторизация определяет, какие действия может выполнять пользователь в пределах системы на основе его роли или прав доступа.

# JWT

JWT (JSON Web Token) - это открытый стандарт (RFC 7519), который определяет компактный и безопасный способ передачи информации между двумя участниками в виде закодированного JSON объекта. JWTs используются для авторизации и аутентификации пользователей в приложениях и API. JWT может содержать утверждения (claims) о пользователе, такие как идентификатор пользователя, истекшее время действия токена и разрешения пользователя.

JWT зашифрован и подписан с помощью ключа, чтобы предотвратить несанкционированный доступ или изменение данных.

Токены создаются сервером, подписываются секретным ключом и передаются клиенту.

Для его создания необходимо определить заголовок (header) с общей информацией по токену, полезные данные (payload), такие как id пользователя, его роль и т.д. и подписи (signature).

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0
```

## Структура

**Header**

Обычно заголовок состоит из двух полей: типа токена (в данном случае JWT) и алгоритма хэширования подписи:


```
{
  "typ": "JWT",
  "alg": "HS256"
}
```

## Payload

Payload — это любые данные, которые вы хотите передать в токене. Но стандарт предусматривает несколько зарезервированных полей:

- iss — (issuer) издатель токена
- sub — (subject) "тема", назначение токена
- aud — (audience) аудитория, получатели токена
- exp — (expire time) срок действия токена
- nbf — (not before) срок, до которого токен не действителен
- iat — (issued at) время создания токена
- jti — (JWT id) идентификатор токена

Все эти поля не являются обязательными, но их использование не по назначению может привести к коллизиям.

Любые другие данные можно передавать по договоренности между сторонами, использующими токен.

Payload не шифруется при использовании токена, поэтому не стоит передавать в нем данные, которые не должны попасть в открытый доступ.

## Signature

Подпись вычисляется на основе заголовка и нагрузки. Таким образом, если кто-то попытается изменить данные в токене, он не сможет изменить подпись, не зная приватного ключа. При аутентификации приватным ключом может выступать пароль пользователя (или хеш от пароля).

## Логика

После первого логина, клиенту возвращается сгенерированный сервером JWT. При каждом следующем запросе, клиент должен передавать JWT установленным API способом (например, через заголовок или как параметр запроса). Сервер декодирует header и payload и проверяет зарезервированные поля. Если все в порядке, по указанному в header алгоритму составляется подпись. Если полученная подпись совпадает с переданной, пользователя авторизуют.

https://vc.ru/dev/106534-jwt-kak-bezopasnyy-sposob-autentifikacii-i-peredachi-dannyh

# Подходы:

![alt](https://i.gyazo.com/9589fd9d75969080a78dc860615616bd.png)

![alt](https://i.gyazo.com/62bed6a55de83cfec1fc72d336bbbe22.png)

## Statefull

- На клиенте только индентификатор
- Содержимое на сервере
- Легко отозвать
- Централизованное хранилище
- Хорошее observability (логи, видим содержимое сессий)

## Stateless

- На клиенте все данные из сессий
- Просто так не отозвать
- Хорошо масштабируется
- Сложно расследовать инциденты постфактум

# Зачем нужен JWT

JWT (JSON Web Token) может использоваться для различных целей в приложениях и API, включая аутентификацию, авторизацию и обмен данными между различными сервисами. Он может быть полезен в следующих случаях:

- Аутентификация: JWT может использоваться для проверки подлинности пользователей и предоставления им доступа к ресурсам на основе подтвержденной личности.

- Авторизация: JWT может содержать информацию о разрешениях пользователя, позволяя ограничить доступ к определенным ресурсам и функциям.

- Обмен данными между различными приложениями: JWT может использоваться для безопасной передачи данных между различными сервисами без необходимости повторной аутентификации на каждом этапе.

- Уменьшение нагрузки на сервер: JWT хранится на стороне клиента и содержит все необходимые данные, что позволяет снизить количество запросов к серверу для проверки подлинности и авторизации.

В целом, JWT является удобным и безопасным способом передачи информации между различными приложениями и сервисами в рамках одной или нескольких доверенных сред.


# Проблема аутентификации через JWT (JWT и сессии) JWT as a session mechanism

![alt](https://i.gyazo.com/a498e9c88d6c6d604f45433757fa68e8.png)

Альтернатива локальному хранилищу

- Вместо того, чтобы хранить JWT в локальном хранилище, сохраните его в файле cookie (не рекомендуется)
- Использовать аутентификацию на стороне сервера с использованием сеансов и файлов cookie (рекомендуется).


В файле cookie: теперь вы все еще уязвимы для CSRF-атак и все еще нуждаетесь в защите от них.

В другом месте, напр. Локальное хранилище: теперь вы не уязвимы для CSRF-атак, но ваше приложение или сайт теперь требуют JavaScript для работы, и вы только что сделали себя уязвимыми для совершенно другого, потенциально худшего класса уязвимостей.

Единственная правильная защита от CSRF — это токен CSRF. Механизм сеанса здесь не имеет значения.

## полезные ссылки

http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/

http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/

https://medium.com/kanlanc/heres-why-storing-jwt-in-local-storage-is-a-great-mistake-df01dad90f9e

https://evertpot.com/jwt-is-a-bad-default/

https://medium.com/@rahulgolwalkar/pros-and-cons-in-using-jwt-json-web-tokens-196ac6d41fb

(Authorization: Bearer eyJhbGciOiJIUzI1NiI...)

# Keycloak

Keycloak - это универсальный открытый инструмент для управления аутентификацией и управления доступом (IAM), который решает несколько проблем, связанных с безопасностью приложений и API.

Ниже приведены некоторые проблемы, которые решает Keycloak:

- Упрощение аутентификации: Keycloak предоставляет единое место для аутентификации пользователей в различных приложениях и сервисах. Пользователи могут использовать одинаковые учетные данные для входа в различные системы, что упрощает управление паролями и повышает удобство использования.

- Управление авторизацией: Keycloak обеспечивает надежную систему управления доступом, позволяющую определять права доступа пользователей к различным ресурсам и функциям в системе.

# Механизм авторизации в Laravel

https://laravel.su/docs/8.x/authorization

Laravel предлагает два основных способа авторизации действий: шлюзы и политики.

Шлюз – это просто замыкание, которое определяет, имеет ли пользователь право выполнять указанное действие.

Политики – это классы, которые организуют логику авторизации для конкретной модели или ресурса.


```
php artisan make:policy BookPolicy
php artisan make:policy BookPolicy --model=Book
```
