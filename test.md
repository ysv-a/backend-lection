# Тестирование

Индикатором того что вам нужны тесты на сущ. проекте это то что в системе начали появляться неконтролируемые баги.

Делаете одно, а ломаете другое и у программистов подсознательно возникает боязнь, когда ты не знаешь что твое изменения в системе в одном месте, сломает в другом.

Если код сложно тестировать, скорее всего он обладает высокой связанностью.

Связанность модулей (coupling), часто называемую зацеплением, характеризует степень независимости модулей. При проектировании систем необходимо стремиться, чтобы модули имели минимальную зависимость друг от друга, т.е. были минимально «сцеплены» между собой (отсюда и термин «сцепление» или связанность). Это требование вытекает из одного из основных принципов системного подхода, требующего минимизации информационных потоков между подсистемами.

Связность (cohesion) характеризует целостность, «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования. В идеале модуль должен выполнять одну единственную функцию и иметь минимальное число «ручек управления».

![alt](https://i.gyazo.com/b830abd644d9efbda65b414656a58884.png)

Тесты - доказательство того что ваш код работает

## e2e - функциональные тесты (приёмочное)

Тестирует систему как если бы ей пользовался пользователь. Проверяет приложение на соответствие функциональным требованиям.

(Бекенд может проверить ендпоинты. Фронт, заполнение полей формы)

Выполняются медленно, говорят что в системе что-то не так, но кто виноват не говорят

Тест, который делает запрос в приложение, а потом лезет в базу данных проверять результат, не является настоящим функциональным тестом.

Функциональное тестирование не про базу данных, оно о приложении в целом. Поэтому нормальные функциональные тесты не лезут внутрь приложения, они работают снаружи.

## Интеграционные тесты

Тестирует взаимодействия нескольких модулей.

Фронтенд: исп. несколько компонентов + стора которая работает вместе с ними

Бекенд: попросить UserService зарегистрировать нового пользователя и проверить, что новая строка создана в базе данных, нужное событие (UserRegistered) было сгенерировано и соответствующий email был послан.


## Unit тесты

Тестируют один конкретный модуль.

Выполняются быстро, способны локализовать проблемы в рамках одного юнита и не всегда они проверяют общую бизнес логику.

Unit тесты - функционирует как инструмент описания бизнес требований к модулю, тесты проверяют что выполняются бизнес требования.

Unit тесты осуществляют очень важную задачу, документирование поведения конкретного узла системы.

Когда методы класса полностью независимы друг от друга, класс не является модулем.

Unit тесты должно быть легко писать чтоб о них было легко думать, иначе любой сложный запутанный unit тест говорит о том что архитектура вашей системы несколько хромает и если это сложно понимать в тесте, значит и саму систему сложно понять и нужно ее упрощать.

Никогда не занимайтесь тем что просто бездумно пишите тесты, например, на все методы класса, это плохой и тупиковый подход, потому что такие тесты очень редко несут бизнес ценности, большая часть методов класса является внутренними.


Тесты  проверяют сценарии которые мы написали, когда тест зеленый, не всегда означает что модуль рабочий, но если обнаруживаем что модуль не рабочий, а тесты остаются зелеными, дописываем новые тесты.

Если тест является красным, то проблема должна быть в модуле который тестируется.


## Честность и хрупкость

есть модуль A который взаимодействует с модулем B

A -> B

и например какой то метод из модуля B, который исп. модуль А, присылает не корректные данные, модуль А, соо-о упадет

и тесты модуля А, укажут что модуль А не работает

но на самом деле, модуль А ведет себя корректно, это модуль проблема с модулем B, мы должны полностью изолировать модуль А от чужого кода т.е значит там где у нас в модуле А вызвался модуль B, должно быть вызвано что-то другое, и так должно быть во всеми внешними зависимостями модуля А.


### Честность

Честность - падение нашего теста, указывает нам на проблемы именно модуля который он тестирует, проблемы в любых других модулях не должны приводить к падению нашего теста.

Если мы знаем что наш модуль не работает, но тесты являются зелеными, то мы расширяем тесты, для того чтобы тесты стали красными и потом чиним модуль.

### Хрупкость

Тестировать мы можем только то что наш модуль предоставляет наружу, рефакторинг модуля А при котором внешнее поведение сохраняется, не приводит к падению теста.

## AAA - шаблон

Любой тест состоит из 3х шагов:

- Arrange - Подготовка
- Act - Выполнение
- Assert - Проверка

в Act фазе должны быть только те операции которые мы реально тестируем? иначе если там будет слишком много операции, окажется что наш тест перестает быть честным.

## 5 видов заменимых объектов

### Dummy

например модулю нужен объект конфигурации, можно подсунуть в Dummy пустой конфиг.

### Fake

фейковые объекты, содержат в себе логику, только они как-то ее упрощают.

### Stub

заглушка, просто содержит набор правил, когда вызывается метод, возвращает заранее известные данные. Cодержит набор правил как отвечать

### Spy

внутри себя отслеживает какое-то состояние, например сколько раз была отправлена почта

### Mocks

заглушка, которая содержит ожидания, о том с какими параметрами она будет вызвана

(например, будет вызван метод с параметрами (x1,x2) и если он будет вызвана с др. параметрами, на которые он не настроен, это приведет к провалу теста если вызовем неизвестный метод, тест упадет)

Fake, Stub и Mocks имеют общее имя - test doubles, название для объектов, которые подставляются вместо реальных с целью тестирования.

Стабы и моки удобны когда нужно быстро настроить простую реализацию, но когда тестов с зависимостью становится много, фэйковый класс смотрится пооптимальнее.

## Fixtures

это Стабы которые связаны не с реализации конкретных элементов вашей системы, а являются зафиксированными ответами.

Фронтенд:

некие данные, которые подменяют ответ бекенда

Бекенд:

база данных которая загружается в бекенде перед началом тестов

как и стабы, Fixtures могут устаревать, т.е реально на бекенде могут быть др данные, а через Fixtures возвращаются старые данные
